0000              1   ; main program to be run 
                  3   $LIST
0000              5   
0000              6   ;  N76E003 pinout:
0000              7   ;                               -------
0000              8   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000              9   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             10   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             11   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             12   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             13   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             14   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             15   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             16   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             17   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             18   ;                               -------
0000             19   ;
0000             20   
0000             21   ;----------------clock values---------------------
0000             22   CLK               EQU 16600000 ; Microcontroller system frequency in Hz
0000             23   BAUD              EQU 115200 ; Baud rate of UART in bps
0000             24   TIMER1_RELOAD     EQU (0x100-(CLK/(16*BAUD)))
0000             25   TIMER0_RATE              EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             26   
0000             27   TIMER0_RELOAD            EQU ((65536-(CLK/TIMER0_RATE)))
0000             28   TIMER2_RATE         EQU 1000    ; 1000Hz, for a timer tick of 1ms
0000             29   TIMER2_RELOAD            EQU ((65536-(CLK/TIMER2_RATE)))
0000             30   
0000             31   PAGE_ERASE_AP   EQU 00100010b    ;for flash memory
0000             32   BYTE_PROGRAM_AP EQU 00100001b
0000             33   
0000             34   ORG 0x0000
0000 020749      35            ljmp MainProgram
0003             36   
0003             37   ; External interrupt 0 vector (not used in this code)
0003             38   org 0x0003
0003 32          39            reti
0004             40   
0004             41   ; Timer/Counter 0 overflow interrupt vector
000B             42   org 0x000B
000B 02057B      43            ljmp Timer0_ISR
000E             44   
000E             45   ; External interrupt 1 vector (not used in this code)
0013             46   org 0x0013
0013 32          47            reti
0014             48   
0014             49   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             50   org 0x001B
001B 32          51            reti
001C             52   
001C             53   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             54   org 0x0023 
0023 32          55            reti
0024             56            
0024             57   ; Timer/Counter 2 overflow interrupt vector
002B             58   org 0x002B
002B 0205A3      59            ljmp Timer2_ISR
002E             60   
002E             61   
002E             62   ;               1234567890123456    <- This helps determine the location of the counter
002E 534F414B    63   param1:     db 'SOAK TEMP:      ', 0
     2054454D
     503A2020
     20202020
     00
003F 534F414B    64   param2:     db 'SOAK TIME:      ', 0
     2054494D
     453A2020
     20202020
     00
0050 5245464C    65   param3:     db 'REFLOW TEMP:    ', 0
     4F572054
     454D503A
     20202020
     00
0061 5245464C    66   param4:     db 'REFLOW TIME:     ', 0
     4F572054
     494D453A
     20202020
     2000
0073 2D3E5354    67   startmsg:     db '->START 2 START  ', 0
     41525420
     32205354
     41525420
     2000
0085 2D3E4544    68   editmsg:     db '->EDIT 2 EDIT    ', 0
     49542032
     20454449
     54202020
     2000
0097 434F4E46    69   title06:     db 'CONFIRM?           ', 0
     49524D3F
     20202020
     20202020
     20202000
00AB 5245464C    70   title07:     db 'REFLOW TIME?       ', 0
     4F572054
     494D453F
     20202020
     20202000
00BF 434F4E46    71   title08:     db 'CONFIRM?           ', 0
     49524D3F
     20202020
     20202020
     20202000
00D3 31205241    72   title1:     db '1 RAMP   Ts:       ', 0
     4D502020
     2054733A
     20202020
     20202000
00E7 3220534F    73   title2:     db '2 SOAK             ', 0
     414B2020
     20202020
     20202020
     20202000
00FB 33205241    74   title3:     db '3 RAMP   Tr:       ', 0
     4D502020
     2054723A
     20202020
     20202000
010F 34205245    75   title4:     db '4 REFLOW           ', 0
     464C4F57
     20202020
     20202020
     20202000
0123 3520434F    76   title5:     db '5 COOLING          ', 0
     4F4C494E
     47202020
     20202020
     20202000
0137 20202020    77   blank:     db '                  ', 0
     20202020
     20202020
     20202020
     202000
014A             78   
014A             79   cseg
014A             80   ; These 'equ' must match the hardware wiring
014A             81   LCD_RS equ P1.3
014A             82   LCD_E  equ P1.4
014A             83   LCD_D4 equ P0.0
014A             84   LCD_D5 equ P0.1
014A             85   LCD_D6 equ P0.2
014A             86   LCD_D7 equ P0.3
014A             87   
014A             88   PWM_OUT     equ P1.0 ; logic=1 oven on
014A             89   SOUND_OUT        equ P1.6
014A             90   
014A             91   ;-------------------------------------------------------
0030             92   DSEG at 0x30
0030             93   
0030             94   ;---------------temp validation----------------------
0030             95   
0030             96   x:   ds 4
0034             97   y:   ds 4
0038             98   bcd: ds 5
003D             99   VLED_ADC: ds 2
003F            100   
003F            101   
003F            102   ;----------------- clock and speaker ------------------------------
003F            103   Count1ms:               ds 2 ;to determine when one second has passed
0041            104   secs_ctr:               ds 1
0042            105   mins_ctr:               ds 1
0043            106   
0043            107   
0043            108   state_secs_ctr:                  ds 2
0045            109   
0045            110   buzzer:                                  ds 1
0046            111   
0046            112   ;-----------------FSM-s-------------------
0046            113   FSM1_state:             ds 1 ; determine state
0047            114   edit_state:                              ds 1
0048            115   
0048            116   ;----------------fsm values--------------------
0048            117   stemp:                                   ds 2
004A            118   stime:                                   ds 2
004C            119   rtemp:                                   ds 2
004E            120   rtime:                                   ds 2
0050            121   stime_bcd:                               ds 2
0052            122   rtime_bcd:                               ds 2
0054            123   
0054            124   ;-----------------timer values-----------------
0054            125   soak_timer:             ds 2
0056            126   reflow_timer:           ds 1
0057            127   
0057            128   ;----------------PWM-----------------
0057            129   pwm_counter:            ds 1
0058            130   pwm:                    ds 1
0059            131   
0059            132   ;------------------oven temp-------------
0059            133   oven_temp:                               ds 2
005B            134   
005B            135   
005B            136   ;-------------------flags-----------------------------
0000            137   BSEG 
0000            138   mf: dbit 1
0001            139   one_second_flag: dbit 1
0002            140   
0002            141   ;----------------push buttons------------------
0002            142   incr:                    dbit 1
0003            143   decr:                    dbit 1
0004            144   edit:                    dbit 1
0005            145   reset:                   dbit 1
0006            146   start_stop:              dbit 1
0007            147   
0007            148   ;---------------soak and reflow time flag-------------
0007            149   soak_timer_flag:    dbit 1
0008            150   reflow_timer_flag:  dbit 1
0009            151   soak_temp_flag:    dbit 1
000A            152   reflow_temp_flag:  dbit 1
000B            153   ;--------------PWM flag---------------------
000B            154   pwm_flag:           dbit 1
000C            155   
                546   $LIST
                158   $LIST
046E            160   ;---------flash memory functions-------------
046E            161   putchar:
046E 3099FD     162       JNB TI, putchar
0471 C299       163       CLR TI
0473 F599       164       MOV SBUF, a
0475 22         165       RET
0476            166   
0476            167   SendString:
0476 E4         168       CLR A
0477 93         169       MOVC A, @A+DPTR
0478 6006       170       JZ SSDone
047A 12046E     171       LCALL putchar
047D A3         172       INC DPTR
047E 80F6       173       SJMP SendString
0480            174   SSDone:
0480 22         175       ret
0481            176   
0481            177   ; Sends the byte in the accumulator to the serial port in decimal 
0481            178   Send_byte:
0481 75F064     179            mov b, #100
0484 84         180            div ab
0485 4430       181            orl a, #'0'
0487 12046E     182            lcall putchar
048A E5F0       183            mov a, b
048C 75F00A     184            mov b, #10
048F 84         185            div ab
0490 4430       186            orl a, #'0'
0492 12046E     187            lcall putchar
0495 E5F0       188            mov a, b
0497 4430       189            orl a, #'0'
0499 12046E     190            lcall putchar
049C 740D       191            mov a, #'\r'
049E 12046E     192            lcall putchar
04A1 740A       193            mov a, #'\n'
04A3 12046E     194            lcall putchar
04A6 22         195            ret
04A7            196   
04A7            197   ;---------------------------------;
04A7            198   ; Routine to initialize the pins  ;
04A7            199   ; for input out - ADC inc         ;
04A7            200   ;---------------------------------;
04A7            201   Init_All:
04A7            202            ; Configure all the pins for biderectional I/O
04A7 75AC00     203            mov     P3M1, #0x00
04AA 75AD00     204            mov     P3M2, #0x00
04AD 75B300     205            mov     P1M1, #0x00
04B0 75B400     206            mov     P1M2, #0x00
04B3 75B100     207            mov     P0M1, #0x00
04B6 75B200     208            mov     P0M2, #0x00
04B9            209            
04B9 438E10     210            orl     CKCON, #0x10 ; CLK is the input for timer 1
04BC 438780     211            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
04BF 759852     212            mov     SCON, #0x52
04C2 53C4DF     213            anl     T3CON, #0b11011111
04C5 53890F     214            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
04C8 438920     215            orl     TMOD, #0x20 ; Timer 1 Mode 2
04CB 758DF7     216            mov     TH1, #TIMER1_RELOAD ; TH1=TIMER1_RELOAD;
04CE D28E       217            setb TR1
04D0            218            
04D0 759852     219            mov SCON, #52H
04D3            220            
04D3            221            
04D3            222            ; Using timer 0 for delay functions.  Initialize here:
04D3 C28C       223            clr     TR0 ; Stop timer 0
04D5 438E08     224            orl     CKCON,#0x08 ; CLK is the input for timer 0
04D8 5389F0     225            anl     TMOD,#0xF0 ; Clear the configuration bits for timer 0
04DB 438901     226            orl     TMOD,#0x01 ; Timer 0 in Mode 1: 16-bit timer
04DE            227            
04DE            228            ; Initialize the pins used by the ADC (P1.1, P1.7) as input.
04DE 43B382     229            orl     P1M1, #0b10000010
04E1 53B47D     230            anl     P1M2, #0b01111101
04E4            231            
04E4            232            ; Since the reset button bounces, we need to wait a bit before
04E4            233       ; sending messages, otherwise we risk displaying gibberish!
04E4 79C8       234            mov R1, #200
04E6 7868       235       mov R0, #104
04E8 D8FE       236       djnz R0, $   ; 4 cycles->4*60.285ns*104=25us
04EA D9FA       237       djnz R1, $-4 ; 25us*200=5.0ms
04EC            238            
04EC            239            ; Initialize and start the ADC:
04EC 53E8F0     240            anl ADCCON0, #0xF0
04EF 43E807     241            orl ADCCON0, #0x07 ; Select channel 7
04F2            242            ; AINDIDS select if some pins are analog inputs or digital I/O:
04F2 75F600     243            mov AINDIDS, #0x00 ; Disable all analog inputs
04F5 43F681     244            orl AINDIDS, #0b10000001 ; Activate AIN0 and AIN7 analog inputs
04F8 43E101     245            orl ADCCON1, #0x01 ; Enable ADC
04FB            246            
04FB 22         247            ret
04FC            248   
04FC            249   ;-----------functions for temp reading ADC-----------
04FC            250   Read_ADC:
04FC C2EF       251            clr ADCF
04FE D2EE       252            setb ADCS ;  ADC start trigger signal
0500 30EFFD     253       jnb ADCF, $ ; Wait for conversion complete
0503            254       
0503            255       ; Read the ADC result and store in [R1, R0]
0503 E5C2       256       mov a, ADCRL
0505 540F       257       anl a, #0x0f
0507 F8         258       mov R0, a
0508 E5C3       259       mov a, ADCRH   
050A C4         260       swap a
050B C0E0       261       push acc
050D 540F       262       anl a, #0x0f
050F F9         263       mov R1, a
0510 D0E0       264       pop acc
0512 54F0       265       anl a, #0xf0
0514 48         266       orl a, R0
0515 F8         267       mov R0, A
0516 22         268            ret
0517            269   
                270   Send_BCD mac
                271   	push ar0
                272   	mov r0, %0
                273   	lcall ?Send_BCD
                274   	pop ar0
                275   	endmac
0517            276            
0517            277            ?Send_BCD:
0517 C0E0       278            push acc
0519            279            ; Write most significant digit
0519 E8         280            mov a, r0
051A C4         281            swap a
051B 540F       282            anl a, #0fh
051D 4430       283            orl a, #30h
051F 12046E     284            lcall putchar
0522            285            ; write least significant digit
0522 E8         286            mov a, r0
0523 540F       287            anl a, #0fh
0525 4430       288            orl a, #30h
0527 12046E     289            lcall putchar
052A D0E0       290            pop acc
052C 22         291            ret
052D            292   
                293   	SendChar mac
                294   	push acc
                295   	mov a,%0
                296   	lcall putchar
                297   	pop acc
                298   	endmac
052D            299   
052D            300   Display_formated_BCD:
052D C0E0       301            push acc
052F 7401       301            mov a, #1
0531 14         301            dec a
0532 1201E1     301            lcall ?Set_Cursor_2 ; Select column and row
0535 D0E0       301            pop acc
0537 C000       302            push ar0
0539 A83B       302            mov r0, bcd+3
053B 1201E8     302            lcall ?Display_BCD
053E D000       302            pop ar0
0540 C000       303            push ar0
0542 A83A       303            mov r0, bcd+2
0544 1201E8     303            lcall ?Display_BCD
0547 D000       303            pop ar0
0549 C0E0       304            push acc
054B 742E       304            mov a, #'.'
054D 120199     304            lcall ?WriteData
0550 D0E0       304            pop acc
0552 C000       305            push ar0
0554 A839       305            mov r0, bcd+1
0556 1201E8     305            lcall ?Display_BCD
0559 D000       305            pop ar0
055B C000       306            push ar0
055D A838       306            mov r0, bcd+0
055F 1201E8     306            lcall ?Display_BCD
0562 D000       306            pop ar0
0564            307   
0564 22         308            ret
0565            309   ;---------------------------------;
0565            310   ; Routine to initialize the ISR   ;
0565            311   ; for timer 0                     ;
0565            312   ;---------------------------------;
0565            313   Timer0_Init:
0565 438E08     314            orl CKCON, #0b00001000 ; Input for timer 0 is sysclk/1
0568 E589       315            mov a, TMOD
056A 54F0       316            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
056C 4401       317            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
056E F589       318            mov TMOD, a
0570 758CF0     319            mov TH0, #high(TIMER0_RELOAD)
0573 758A2C     320            mov TL0, #low(TIMER0_RELOAD)
0576            321            ; Enable the timer and interrupts
0576 D2A9       322       setb ET0  ; Enable timer 0 interrupt
0578 D28C       323       setb TR0  ; Start timer 0
057A 22         324            ret
057B            325   
057B            326   ;---------------------------------;
057B            327   ; ISR for timer 0.  Set to execute;
057B            328   ; every 1/4096Hz to generate a    ;
057B            329   ; 2048 Hz wave at pin SOUND_OUT   ;
057B            330   ;---------------------------------;
057B            331   Timer0_ISR:
057B            332            ;clr TF0  ; According to the data sheet this is done for us already.
057B            333            ; Timer 0 doesn't have 16-bit auto-reload, so
057B C28C       334            clr TR0
057D 758CF0     335            mov TH0, #high(TIMER0_RELOAD)
0580 758A2C     336            mov TL0, #low(TIMER0_RELOAD)
0583 D28C       337            setb TR0
0585 B296       338            cpl SOUND_OUT   
0587 32         339            reti
0588            340   
0588            341   ;---------------------------------;
0588            342   ; Routine to initialize the ISR   ;
0588            343   ; for timer 2                     ;
0588            344   ;---------------------------------;
0588            345   Timer2_Init:
0588 75C800     346            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.z
058B 75CDBF     347            mov TH2, #high(TIMER2_RELOAD)
058E 75CC28     348            mov TL2, #low(TIMER2_RELOAD)
0591            349            ; Set the reload value
0591 43C980     350            orl T2MOD, #0x80 ; Enable timer 2 autoreload
0594 75CBBF     351            mov RCMP2H, #high(TIMER2_RELOAD)
0597 75CA28     352            mov RCMP2L, #low(TIMER2_RELOAD)
059A            353            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
059A E4         354            clr a
059B F53F       355            mov Count1ms+0, a
059D F540       356            mov Count1ms+1, a
059F            357            ; Enable the timer and interrupts
059F 439B80     358            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
05A2            359       ;setb TR2  ; Enable timer 2
05A2 22         360            ret
05A3            361   
05A3            362   ;---------------------------------;
05A3            363   ; ISR for timer 2                 ;
05A3            364   ;---------------------------------;
05A3            365   Timer2_ISR:
05A3 C2CF       366            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
05A5 B284       367            cpl P0.4 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
05A7            368            
05A7            369            ; The two registers used in the ISR must be saved in the stack
05A7 C0E0       370            push acc
05A9 C0D0       371            push psw
05AB            372            
05AB            373            ; Increment the 16-bit one mili second counter
05AB 053F       374            inc Count1ms+0    ; Increment the low 8-bits first
05AD E53F       375            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
05AF 7014       376            jnz Inc_Done
05B1 0540       377            inc Count1ms+1
05B3            378            ;mov a, buzzer
05B3            379            ;cjne a, #0, buzzer_out
05B3            380   
05B3            381   pwm_counts:
05B3            382       
05B3 0557       383       inc pwm_counter
05B5 C3         384       clr c
05B6 E558       385       mov a, pwm
05B8 9557       386       subb a, pwm_counter ;If pwm_counter <= pwm then c=1
05BA B3         387            cpl c
05BB 9290       388            mov PWM_OUT, c
05BD            389            
05BD E557       390       mov a, pwm_counter
05BF B46403     391            cjne a, #100, Inc_Done
05C2 755700     392            mov pwm_counter, #0
05C5            393   
05C5            394   
05C5            395   Inc_Done:
05C5            396            ; Check if half second has passed
05C5 E53F       397            mov a, Count1ms+0
05C7 B4E814     398            cjne a, #low(1000), jumper ; Warning: this instruction changes the carry flag!
05CA E540       399            mov a, Count1ms+1
05CC B40329     400            cjne a, #high(1000), Timer2_ISR_done
05CF            401            
05CF            402            ; 500 milliseconds have passed.  Set a flag so the main program knows
05CF D201       403            setb one_second_flag; Let the main program know half second had passed
05D1 B28C       404            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
05D3            405            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
05D3 E4         406            clr a
05D4 F53F       407            mov Count1ms+0, a
05D6 F540       408            mov Count1ms+1, a
05D8            409            ; Increment the BCD counter
05D8 E541       410            mov a, secs_ctr
05DA            411            ;jnb UPDOWN, Timer2_ISR_decrement
05DA 2401       412            add a, #0x01
05DC 8003       413            sjmp clkup
05DE            414   
05DE            415   ;buzzer_out:
05DE            416            ;dec buzzer
05DE            417            ;cpl TR0
05DE            418            ;ljmp pwm_counts
05DE            419            
05DE            420   jumper:
05DE 0205F8     421            ljmp Timer2_ISR_done
05E1            422   
05E1            423   ; clkup:
05E1            424   ;        mov a, state_secs_ctr                                           ;variables for state timers
05E1            425   ;        add a, #1
05E1            426   ;        da a
05E1            427   ;        mov state_secs_ctr, a
05E1            428   ;        mov a, secs_ctr
05E1            429   ;        add a, #1
05E1            430   ;        da a ; Decimal adjust instruction.  Check datasheet for more details!
05E1            431   ;        mov secs_ctr, a
05E1            432   ;        cjne a, #0x60, Timer2_ISR_done
05E1            433   ;        mov secs_ctr, #0x00
05E1            434   ;        mov a, mins_ctr
05E1            435   ;        add a, #1
05E1            436   ;        da a
05E1            437   ;        mov mins_ctr, a
05E1            438   
05E1            439   clkup:
05E1 E543       440            mov a, state_secs_ctr   
05E3 04         441            inc a   ;variables for state timers
05E4 D4         442            da a
05E5 F543       443            mov state_secs_ctr, a
05E7 E541       444            mov a, secs_ctr
05E9 04         445            inc a
05EA D4         446            da a
05EB F541       447            mov secs_ctr, a
05ED B46008     448            cjne a, #0x60, Timer2_ISR_done
05F0 754100     449            mov secs_ctr, #0
05F3 E542       450            mov a, mins_ctr
05F5 04         451            inc a                                    ; Decimal adjust instruction.  Check datasheet for more details!
05F6 F542       452            mov mins_ctr, a
05F8            453   
05F8            454   
05F8            455   Timer2_ISR_done:
05F8 D0D0       456            pop psw
05FA D0E0       457            pop acc
05FC 32         458            reti
05FD            459   
05FD            460   
05FD            461   ;-------------------Generate Display--------------------------
05FD            462   GenerateDisplay:
05FD            463   
05FD            464   MtimerDisplay:
05FD            465   
05FD C0E0       466            push acc
05FF 740F       466            mov a, #15
0601 14         466            dec a
0602 1201E1     466            lcall ?Set_Cursor_2 ; Select column and row
0605 D0E0       466            pop acc
0607 C000       467            push ar0
0609 A841       467            mov r0, secs_ctr
060B 1201E8     467            lcall ?Display_BCD
060E D000       467            pop ar0
0610 C0E0       468            push acc
0612 740E       468            mov a, #14
0614 14         468            dec a
0615 1201E1     468            lcall ?Set_Cursor_2 ; Select column and row
0618 D0E0       468            pop acc
061A C0E0       469            push acc
061C 743A       469            mov a, #':'
061E 120199     469            lcall ?WriteData
0621 D0E0       469            pop acc
0623 C0E0       470            push acc
0625 740C       470            mov a, #12
0627 14         470            dec a
0628 1201E1     470            lcall ?Set_Cursor_2 ; Select column and row
062B D0E0       470            pop acc
062D C000       471            push ar0
062F A842       471            mov r0, mins_ctr
0631 1201E8     471            lcall ?Display_BCD
0634 D000       471            pop ar0
0636            472   
0636            473   TempDisplay:
0636 C0E0       474            push acc
0638 7401       474            mov a, #1
063A 14         474            dec a
063B 1201E1     474            lcall ?Set_Cursor_2 ; Select column and row
063E D0E0       474            pop acc
0640            475            ; Read the 2.08V LED voltage connected to AIN0 on pin 6
0640 53E8F0     476            anl ADCCON0, #0xF0
0643 43E800     477            orl ADCCON0, #0x00 ; Select channel 0
0646            478   
0646 1204FC     479            lcall Read_ADC
0649            480            ; Save result for later use
0649 883D       481            mov VLED_ADC+0, R0
064B 893E       482            mov VLED_ADC+1, R1
064D            483   
064D            484            ; Read the signal connected to AIN7
064D 53E8F0     485            anl ADCCON0, #0xF0
0650 43E807     486            orl ADCCON0, #0x07 ; Select channel 7
0653 1204FC     487            lcall Read_ADC
0656            488       
0656            489       ; Convert to voltage
0656 8830       490            mov x+0, R0
0658 8931       491            mov x+1, R1
065A            492            ; Pad other bits with zero
065A 753200     493            mov x+2, #0
065D 753300     494            mov x+3, #0
0660 753404     495            mov y+0, #low (20740 % 0x10000) 
0663 753551     495            mov y+1, #high(20740 % 0x10000) 
0666 753600     495            mov y+2, #low (20740 / 0x10000) 
0669 753700     495            mov y+3, #high(20740 / 0x10000)  ; The MEASURED LED voltage: 2.074V, with 4 decimal places
066C 120378     496            lcall mul32
066F            497            ; Retrive the ADC LED value
066F 853D34     498            mov y+0, VLED_ADC+0
0672 853E35     499            mov y+1, VLED_ADC+1
0675            500            ; Pad other bits with zero
0675 753600     501            mov y+2, #0
0678 753700     502            mov y+3, #0
067B 120405     503            lcall div32
067E            504            
067E            505   
067E 75344A     506            mov y+0, #low (74 % 0x10000) 
0681 753500     506            mov y+1, #high(74 % 0x10000) 
0684 753600     506            mov y+2, #low (74 / 0x10000) 
0687 753700     506            mov y+3, #high(74 / 0x10000) 
068A 120378     507            lcall mul32
068D 753498     508            mov y+0, #low (207000 % 0x10000) 
0690 753528     508            mov y+1, #high(207000 % 0x10000) 
0693 753603     508            mov y+2, #low (207000 / 0x10000) 
0696 753700     508            mov y+3, #high(207000 / 0x10000)   
0699 1202C3     509            lcall add32
069C            510       ; x is vCH 
069C            511       ; Load_y(27300) ;load 2.73V into y
069C            512       ; lcall sub32
069C            513       ; Load_y(100)
069C            514       ;lcall mul32
069C            515       ;x is now T
069C            516            ; Convert to BCD and display
069C 1201FE     517            lcall hex2bcd
069F 12052D     518            lcall Display_formated_BCD
06A2            519            
06A2 C000       520            push ar0
06A4 A83B       520            mov r0, bcd+3
06A6 120517     520            lcall ?Send_BCD
06A9 D000       520            pop ar0
06AB C000       521            push ar0
06AD A83A       521            mov r0, bcd+2
06AF 120517     521            lcall ?Send_BCD
06B2 D000       521            pop ar0
06B4 C0E0       522            push acc
06B6 742E       522            mov a,#'.'
06B8 12046E     522            lcall putchar
06BB D0E0       522            pop acc
06BD C000       523            push ar0
06BF A839       523            mov r0, bcd+1
06C1 120517     523            lcall ?Send_BCD
06C4 D000       523            pop ar0
06C6 C000       524            push ar0
06C8 A838       524            mov r0, bcd+0
06CA 120517     524            lcall ?Send_BCD
06CD D000       524            pop ar0
06CF C0E0       525            push acc
06D1 740A       525            mov a,#'\n'
06D3 12046E     525            lcall putchar
06D6 D0E0       525            pop acc
06D8            526   
06D8 853A59     527            mov oven_temp+0, bcd+2                  ;saving the oven temp
06DB 853B5A     528            mov oven_temp+1, bcd+3
06DE            529   
06DE 22         530            ret
06DF            531   
06DF            532   ;-----------------lcd pushbuttons--------------------------
06DF            533   LCD_PB:
06DF            534            ; Set variables to 1: 'no push button pressed'
06DF D202       535            setb incr
06E1 D203       536            setb decr
06E3 D204       537            setb edit
06E5 D206       538            setb start_stop
06E7 D205       539            setb reset
06E9            540            ; The input pin used to check set to '1'
06E9 D295       541            setb P1.5
06EB            542            
06EB            543            ; Check if any push button is pressed
06EB C280       544            clr P0.0
06ED C281       545            clr P0.1
06EF C282       546            clr P0.2
06F1 C283       547            clr P0.3
06F3 C293       548            clr P1.3
06F5 20953A     549            jb P1.5, LCD_PB_Done
06F8            550   
06F8            551            ; Debounce
06F8 7A32       552            mov R2, #50
06FA 120743     553            lcall waitms
06FD 209532     554            jb P1.5, LCD_PB_Done
0700            555   
0700            556            ; Set the LCD data pins to logic 1
0700 D280       557            setb P0.0
0702 D281       558            setb P0.1
0704 D282       559            setb P0.2
0706 D283       560            setb P0.3
0708 D293       561            setb P1.3
070A            562            
070A            563            ; Check the push buttons one by one
070A C293       564            clr P1.3
070C A295       565            mov c, P1.5
070E 9205       566            mov reset, c
0710 D293       567            setb P1.3
0712            568   
0712 C280       569            clr P0.0
0714 A295       570            mov c, P1.5
0716 9206       571            mov start_stop, c
0718 D280       572            setb P0.0
071A            573            
071A C281       574            clr P0.1
071C A295       575            mov c, P1.5
071E 9204       576            mov edit, c
0720 D281       577            setb P0.1
0722            578            
0722 C282       579            clr P0.2
0724 A295       580            mov c, P1.5
0726 9203       581            mov decr, c
0728 D282       582            setb P0.2
072A            583            
072A C283       584            clr P0.3
072C A295       585            mov c, P1.5
072E 9202       586            mov incr, c
0730 D283       587            setb P0.3
0732            588   
0732            589   LCD_PB_Done:             
0732 22         590            ret
0733            591   
0733            592   wait_1ms:
0733 C28C       593            clr     TR0 ; Stop timer 0
0735 C28D       594            clr     TF0 ; Clear overflow flag
0737 758CF0     595            mov     TH0, #high(TIMER0_RELOAD)
073A 758A2C     596            mov     TL0,#low(TIMER0_RELOAD)
073D D28C       597            setb TR0
073F 308DFD     598            jnb     TF0, $ ; Wait for overflow
0742 22         599            ret
0743            600   
0743            601   ; Wait the number of miliseconds in R2
0743            602   waitms:
0743 120733     603            lcall wait_1ms
0746 DAFB       604            djnz R2, waitms
0748 22         605            ret
0749            606   
0749            607   ;--------------------------------- Main Program --------------------------------
0749            608   
0749            609   MainProgram:                            ;main program
0749            610       
0749 75817F     611       mov SP, #0x7f
074C 1204A7     612       lcall Init_All
074F 1201A3     613       lcall LCD_4BIT                                        ; initialize settings
0752            614   
0752 C201       615       clr one_second_flag     
0754 C207       616       clr soak_timer_flag                               ; flags
0756 C208       617       clr reflow_timer_flag
0758 C20B       618       clr pwm_flag
075A            619   
075A 754600     620       mov FSM1_state, #0
075D 754700     621            mov edit_state, #0
0760            622                                                ; fsm
0760 754100     623       mov secs_ctr, #0                                    ; clock
0763 754200     624       mov mins_ctr, #0
0766 755400     625       mov soak_timer, #0
0769 755600     626       mov reflow_timer, #0
076C 754500     627            mov buzzer, #0
076F 755700     628            mov pwm_counter, #0
0772            629                                           ; edit settings
0772            630       ;lcall Timer1_Init                                    ; timers
0772 120588     631       lcall Timer2_Init
0775            632            ;lcall Timer0_Init
0775 D2CA       633            setb TR2
0777 D2AF       634       setb EA
0779            635   
0779            636   
0779            637   
0779 754850     638       mov stemp+0, #0x50
077C 754901     639            mov stemp+1, #0x01
077F 754A3C     640            mov stime, #60
0782 E54A       641            mov a, stime
0784 D4         642            da a 
0785 F550       643            mov stime_bcd, a
0787 754C17     644            mov rtemp+0, #0x17
078A 754D02     645       mov rtemp+1, #0x02
078D 754E2D     646            mov rtime, #45
0790 E54E       647            mov a, rtime
0792 D4         648            da a 
0793 F552       649            mov rtime_bcd, a
0795            650       
0795            651                                           ; 
0795            652   
0795            653   forever:  
0795 300105     654       jnb one_second_flag, SkipDisplay            ;every second, the screen should update
0798 C201       655       clr one_second_flag
079A 1205FD     656       lcall GenerateDisplay 
079D            657            
079D            658   
079D            659   SkipDisplay:                                    ;if no display needed
079D            660                                                     
079D 020854     661            ljmp FSM1
07A0            662   ;-----------------------------------------------------------------
07A0            663   
07A0            664   ;-----------------------check_stop_restart-----------------------
07A0            665   check_stop_restart:
07A0 1206DF     666            lcall LCD_PB                            ;evaluate the buttons   ;need to wait so dont need lightning button presses
07A3 A206       667            mov c, start_stop
07A5 5005       668            jnc stop_protocol
07A7 A205       669            mov c, reset
07A9 5008       670            jnc reset_protocol
07AB 22         671            ret
07AC            672   
07AC            673   
07AC            674   stop_protocol:
07AC 755800     675            mov pwm, #0
07AF 754600     676            mov FSM1_state, #0
07B2 22         677            ret
07B3            678   
07B3            679   reset_protocol:
07B3 755800     680            mov pwm, #0                                     ;turn off oven
07B6 754600     681            mov FSM1_state, #0                      ;go back to select stage
07B9 22         682            ret
07BA            683   
07BA            684   
07BA            685   ;----------------------------load functions to compare values------
07BA            686   load_soak_temp:
07BA C0E0       687            push acc
07BC C0D0       688            push psw
07BE C200       689            clr mf
07C0 E4         690            clr A
07C1            691   
07C1 F530       692            mov x+0,a
07C3 F531       693            mov x+1,a
07C5 F532       694            mov x+2,a
07C7 F533       695            mov x+3,a
07C9            696            
07C9 F534       697            mov y+0,a
07CB F535       698            mov y+1,a
07CD F536       699            mov y+2,a
07CF F537       700            mov y+3,a
07D1            701            
07D1            702   
07D1 854830     703            mov x+0, stemp+0
07D4 854931     704            mov x+1, stemp+1
07D7            705            
07D7 855934     706            mov y+0, oven_temp+0
07DA 855A35     707            mov y+1, oven_temp+1
07DD            708            
07DD D0D0       709            pop psw
07DF D0E0       710            pop acc
07E1 22         711            ret
07E2            712   
07E2            713   load_reflow_temp:
07E2 C0E0       714            push acc
07E4 C0D0       715            push psw
07E6 C200       716            clr mf
07E8 E4         717            clr a
07E9            718            
07E9 F530       719            mov x+0,a
07EB F531       720            mov x+1,a
07ED F532       721            mov x+2,a
07EF F533       722            mov x+3,a
07F1            723            
07F1 F534       724            mov y+0,a
07F3 F535       725            mov y+1,a
07F5 F536       726            mov y+2,a
07F7 F537       727            mov y+3,a
07F9            728            
07F9            729   
07F9 854C30     730            mov x+0, rtemp+0
07FC 854D31     731            mov x+1, rtemp+1
07FF            732            
07FF 855934     733            mov y+0, oven_temp+0
0802 855A35     734            mov y+1, oven_temp+1
0805            735            
0805 D0D0       736            pop psw
0807 D0E0       737            pop acc
0809 22         738            ret
080A            739   
080A            740   load_abort_temp:
080A C0E0       741            push acc
080C C0D0       742            push psw
080E C200       743            clr mf
0810 E4         744            clr a
0811            745            
0811 F530       746            mov x+0,a
0813 F531       747            mov x+1,a
0815 F532       748            mov x+2,a
0817 F533       749            mov x+3,a
0819            750            
0819 F534       751            mov y+0,a
081B F535       752            mov y+1,a
081D F536       753            mov y+2,a
081F F537       754            mov y+3,a
0821            755   
0821 753050     756            mov x+0, #0x50
0824            757            
0824 855934     758            mov y+0, oven_temp+0
0827 855A35     759            mov y+1, oven_temp+1
082A            760   
082A D0D0       761            pop psw
082C D0E0       762            pop acc
082E 22         763            ret
082F            764   
082F            765   load_cooling_temp:
082F C0E0       766            push acc
0831 C0D0       767            push psw
0833 C200       768            clr mf
0835 E4         769            clr a
0836            770            
0836 F530       771            mov x+0,a
0838 F531       772            mov x+1,a
083A F532       773            mov x+2,a
083C F533       774            mov x+3,a
083E            775            
083E F534       776            mov y+0,a
0840 F535       777            mov y+1,a
0842 F536       778            mov y+2,a
0844 F537       779            mov y+3,a
0846            780   
0846 753050     781            mov x+0, #0x50
0849            782            
0849 855934     783            mov y+0, oven_temp+0
084C 855A35     784            mov y+1, oven_temp+1
084F            785   
084F D0D0       786            pop psw
0851 D0E0       787            pop acc
0853 22         788            ret
0854            789   
0854            790   
0854            791   
0854            792   ;--------------------------------- FSM --------------------------------
0854            793   FSM1:
0854 E546       794       mov a, FSM1_state                            ; initializes which state to start from
0856            795   
0856            796   FSM1_state0:                                             ; start or not and edit settings
0856 B40026     797       cjne a, #0, FSM1_state1              ; if state is not 0, then move to the next
0859 020A0B     798       ljmp FSM_edit
085C 755800     799       mov pwm, #0                                          ; pulse width modulation set to 0
085F 754100     800            mov secs_ctr, #0
0862            801   
0862            802   FSM1_state0_done:
0862 7401       803            mov a, #0x01
0864 12019E     803            lcall ?WriteCommand
0867            803   
0867 C002       804            push AR2
0869 7A02       804            mov R2, #2
086B 120154     804            lcall ?Wait_Milli_Seconds
086E D002       804            pop AR2
0870 754601     805            mov FSM1_state, #1                      ; change the state to the next
0873 754100     806            mov secs_ctr, #0
0876 754200     807            mov mins_ctr, #0
0879 754501     808            mov buzzer, #1
087C            809            
087C 020795     810       ljmp forever
087F            811   
087F            812   FSM1_state1:                                             ; ramp to soak
087F B40171     813       cjne a, #1, FSM1_state2
0882 C0E0       814            push acc
0884 7401       814            mov a, #1
0886 14         814            dec a
0887 1201E3     814            lcall ?Set_Cursor_1 ; Select column and row
088A D0E0       814            pop acc
088C C083       815            push dph
088E C082       815            push dpl
0890 C0E0       815            push acc
0892 9000D3     815            mov dptr, #title1
0895 1201D6     815            lcall ?Send_Constant_String
0898 D0E0       815            pop acc
089A D082       815            pop dpl
089C D083       815            pop dph
089E C0E0       816            push acc
08A0 740D       816            mov a, #13
08A2 14         816            dec a
08A3 1201E3     816            lcall ?Set_Cursor_1 ; Select column and row
08A6 D0E0       816            pop acc
08A8 C000       817            push ar0
08AA A849       817            mov r0, stemp+1
08AC 1201E8     817            lcall ?Display_BCD
08AF D000       817            pop ar0
08B1 C000       818            push ar0
08B3 A848       818            mov r0, stemp+0
08B5 1201E8     818            lcall ?Display_BCD
08B8 D000       818            pop ar0
08BA 755864     819       mov pwm, #100                                        ; set power to full
08BD 7400       820            mov a, #0
08BF B54218     821            cjne a, mins_ctr, check_abort
08C2 1207BA     822            lcall load_soak_temp                    ;soak temp in x , oven in y
08C5 120364     823            lcall x_gteq_y
08C8 200022     824            jb mf, FSM1_state1_done
08CB            825   
08CB 754602     826       mov FSM1_state, #2
08CE 7401       827            mov a, #0x01
08D0 12019E     827            lcall ?WriteCommand                             ; clear thje tiomer area
08D3 C209       828            clr soak_temp_flag
08D5 D207       829       setb soak_timer_flag                 ; start the timer for soak
08D7 754300     830            mov state_secs_ctr, #0                          ;set the timer for states
08DA            831   ;-------------------------------abort subroutines---------------------
08DA            832   check_abort: 
08DA 12080A     833            lcall load_abort_temp           ;if temp<50 after a min, abort.
08DD 120322     834            lcall x_gt_y
08E0 200001     835            jb mf, abort_process
08E3 22         836            ret
08E4            837   
08E4            838   abort_process:
08E4 755800     839            mov pwm, #0
08E7 754600     840            mov FSM1_state, #0
08EA 020795     841            ljmp forever
08ED            842   
08ED            843   FSM1_state1_done:
08ED 754502     844            mov buzzer, #2
08F0 020795     845       ljmp forever
08F3            846   
08F3            847   FSM1_state2: ;soak
08F3 B40246     848       cjne a, #2, FSM1_state3
08F6 C0E0       849            push acc
08F8 7401       849            mov a, #1
08FA 14         849            dec a
08FB 1201E3     849            lcall ?Set_Cursor_1 ; Select column and row
08FE D0E0       849            pop acc
0900 C083       850            push dph
0902 C082       850            push dpl
0904 C0E0       850            push acc
0906 9000E7     850            mov dptr, #title2
0909 1201D6     850            lcall ?Send_Constant_String
090C D0E0       850            pop acc
090E D082       850            pop dpl
0910 D083       850            pop dph
0912 C0E0       851            push acc
0914 740D       851            mov a, #13
0916 14         851            dec a
0917 1201E3     851            lcall ?Set_Cursor_1 ; Select column and row
091A D0E0       851            pop acc
091C C000       852            push ar0
091E A843       852            mov r0, state_secs_ctr
0920 1201E8     852            lcall ?Display_BCD
0923 D000       852            pop ar0
0925 755814     853       mov pwm, #20
0928 E543       854       mov a, state_secs_ctr
092A C3         855            clr c 
092B 954A       856            subb a, stime
092D 400A       857            jc FSM1_state2_done
092F            858   
092F 754603     859       mov FSM1_state, #3
0932 C207       860            clr soak_timer_flag
0934 7401       861            mov a, #0x01
0936 12019E     861            lcall ?WriteCommand                     ; clear thje tiomer area
0939            862   
0939            863   FSM1_state2_done:
0939            864   
0939 020795     865       ljmp forever
093C            866   
093C            867   FSM1_state3:                                             ;ramp to reflow
093C B40350     868       cjne a, #3, FSM1_state4
093F C0E0       869            push acc
0941 7401       869            mov a, #1
0943 14         869            dec a
0944 1201E3     869            lcall ?Set_Cursor_1 ; Select column and row
0947 D0E0       869            pop acc
0949 C083       870            push dph
094B C082       870            push dpl
094D C0E0       870            push acc
094F 9000FB     870            mov dptr, #title3
0952 1201D6     870            lcall ?Send_Constant_String
0955 D0E0       870            pop acc
0957 D082       870            pop dpl
0959 D083       870            pop dph
095B C0E0       871            push acc
095D 740D       871            mov a, #13
095F 14         871            dec a
0960 1201E3     871            lcall ?Set_Cursor_1 ; Select column and row
0963 D0E0       871            pop acc
0965 C000       872            push ar0
0967 A84D       872            mov r0, rtemp+1
0969 1201E8     872            lcall ?Display_BCD
096C D000       872            pop ar0
096E C000       873            push ar0
0970 A84C       873            mov r0, rtemp+0
0972 1201E8     873            lcall ?Display_BCD
0975 D000       873            pop ar0
0977 755864     874       mov pwm, #100                                        ;ramp to temp
097A 1207E2     875            lcall load_reflow_temp                  ;soak temp in x , oven in y
097D 120364     876            lcall x_gteq_y
0980 200006     877            jb mf, FSM1_state3_done
0983            878   
0983 754604     879       mov FSM1_state, #4
0986 754300     880            mov state_secs_ctr, #0                  ;resetting the state_sec_ctr
0989            881   
0989            882   FSM1_state3_done:
0989 754504     883            mov buzzer, #4
098C 020795     884       ljmp forever
098F            885   
098F            886   FSM1_state4:                                             ;reflow
098F B40442     887       cjne a, #4, FSM1_state5
0992 C0E0       888            push acc
0994 7401       888            mov a, #1
0996 14         888            dec a
0997 1201E3     888            lcall ?Set_Cursor_1 ; Select column and row
099A D0E0       888            pop acc
099C C083       889            push dph
099E C082       889            push dpl
09A0 C0E0       889            push acc
09A2 90010F     889            mov dptr, #title4
09A5 1201D6     889            lcall ?Send_Constant_String
09A8 D0E0       889            pop acc
09AA D082       889            pop dpl
09AC D083       889            pop dph
09AE C0E0       890            push acc
09B0 740D       890            mov a, #13
09B2 14         890            dec a
09B3 1201E3     890            lcall ?Set_Cursor_1 ; Select column and row
09B6 D0E0       890            pop acc
09B8 C000       891            push ar0
09BA A843       891            mov r0, state_secs_ctr
09BC 1201E8     891            lcall ?Display_BCD
09BF D000       891            pop ar0
09C1 755814     892       mov pwm, #20                                         ;keep temp constant
09C4            893       
09C4 E543       894            mov a, state_secs_ctr
09C6 C3         895            clr c 
09C7 9552       896            subb a, rtime_bcd
09C9 4003       897            jc FSM1_state4_done
09CB            898   
09CB 754605     899       mov FSM1_state, #5
09CE            900   
09CE            901   
09CE            902   FSM1_state4_done:
09CE 754505     903            mov buzzer, #5
09D1 020795     904       ljmp forever
09D4            905   
09D4            906   FSM1_state5:                                             ;cooling
09D4 B40531     907       cjne a, #5, FSM1_state0_buffer
09D7 C0E0       908            push acc
09D9 7401       908            mov a, #1
09DB 14         908            dec a
09DC 1201E3     908            lcall ?Set_Cursor_1 ; Select column and row
09DF D0E0       908            pop acc
09E1 C083       909            push dph
09E3 C082       909            push dpl
09E5 C0E0       909            push acc
09E7 900123     909            mov dptr, #title5
09EA 1201D6     909            lcall ?Send_Constant_String
09ED D0E0       909            pop acc
09EF D082       909            pop dpl
09F1 D083       909            pop dph
09F3 755800     910       mov pwm, #0
09F6 12082F     911            lcall load_cooling_temp                         ;50 in x, oven temp in y
09F9 120364     912            lcall x_gteq_y
09FC 300003     913            jnb mf, FSM1_state5_done
09FF            914   
09FF 754600     915       mov FSM1_state, #0
0A02            916   
0A02            917   
0A02            918   FSM1_state5_done:
0A02 754506     919            mov buzzer, #6
0A05 020795     920       ljmp forever
0A08            921   
0A08            922   FSM1_state0_buffer: ;buffer to long jump to state0
0A08            923   
0A08 020856     924       ljmp FSM1_state0
0A0B            925   
0A0B            926   ;-----------------------------------------------------------------
0A0B            927   
0A0B            928   ;---------------------FSM_edit--------------------
0A0B            929   FSM_edit:
0A0B E547       930            mov a, edit_state 
0A0D            931   
0A0D            932   FSM_soaktemp:
0A0D B40009     933            cjne a, #0, FSM_soaktime
0A10 020AA6     934            ljmp soaktemp
0A13            935            
0A13            936   
0A13            937   FSM_soaktemp_done:
0A13 754701     938            mov edit_state, #1
0A16 020A0B     939            ljmp FSM_edit
0A19            940   
0A19            941   FSM_soaktime:
0A19 B40109     942            cjne a, #1, FSM_reflowtemp
0A1C 120B1B     943            call soaktime
0A1F            944   
0A1F            945            
0A1F            946   
0A1F            947   FSM_soaktime_done:
0A1F 754702     948            mov edit_state, #2
0A22 020A0B     949            ljmp FSM_edit
0A25            950   
0A25            951   FSM_reflowtemp:
0A25 B40209     952            cjne a, #2, FSM_reflowtime
0A28 020B86     953            ljmp reflowtemp
0A2B            954   
0A2B            955            
0A2B            956   
0A2B            957   FSM_reflowtemp_done:
0A2B 754703     958            mov edit_state, #3
0A2E 020A0B     959            ljmp FSM_edit
0A31            960   
0A31            961   FSM_reflowtime:
0A31 B40309     962            cjne a, #3, FSM_start
0A34 020BED     963            ljmp reflowtime
0A37            964   
0A37            965            
0A37            966   
0A37            967   FSM_reflowtime_done:
0A37 754704     968            mov edit_state, #4
0A3A 020A0B     969            ljmp FSM_edit
0A3D            970   
0A3D            971   FSM_start:                                               ;can only start once all parameters are selected
0A3D B404CD     972            cjne a, #4, FSM_soaktemp
0A40 1206DF     973            lcall LCD_PB
0A43 C002       974            push AR2
0A45 7A4B       974            mov R2, #75
0A47 120154     974            lcall ?Wait_Milli_Seconds
0A4A D002       974            pop AR2
0A4C C0E0       975            push acc
0A4E 7401       975            mov a, #1
0A50 14         975            dec a
0A51 1201E3     975            lcall ?Set_Cursor_1 ; Select column and row
0A54 D0E0       975            pop acc            ;messages for starting or editing
0A56 C083       976            push dph
0A58 C082       976            push dpl
0A5A C0E0       976            push acc
0A5C 900073     976            mov dptr, #startmsg
0A5F 1201D6     976            lcall ?Send_Constant_String
0A62 D0E0       976            pop acc
0A64 D082       976            pop dpl
0A66 D083       976            pop dph
0A68 C0E0       977            push acc
0A6A 7401       977            mov a, #1
0A6C 14         977            dec a
0A6D 1201E1     977            lcall ?Set_Cursor_2 ; Select column and row
0A70 D0E0       977            pop acc            ;messages for starting or editing
0A72 C083       978            push dph
0A74 C082       978            push dpl
0A76 C0E0       978            push acc
0A78 900085     978            mov dptr, #editmsg
0A7B 1201D6     978            lcall ?Send_Constant_String
0A7E D0E0       978            pop acc
0A80 D082       978            pop dpl
0A82 D083       978            pop dph
0A84 A206       979            mov c, start_stop                       ;start the process
0A86 5007       980            jnc FSM1_state0_done_buffer
0A88 A204       981            mov c, edit                                     ;keep on editing
0A8A 5006       982            jnc FSM_start_done
0A8C 020A3D     983            ljmp FSM_start
0A8F            984   
0A8F            985   
0A8F            986   FSM1_state0_done_buffer:
0A8F 020862     987            ljmp FSM1_state0_done
0A92            988   
0A92            989   FSM_start_done:
0A92 754700     990            mov edit_state, #0          ;clear lcd
0A95 7401       991            mov a, #0x01
0A97 12019E     991            lcall ?WriteCommand
0A9A C002       992            push AR2
0A9C 7A02       992            mov R2, #2
0A9E 120154     992            lcall ?Wait_Milli_Seconds
0AA1 D002       992            pop AR2
0AA3 020A0B     993            ljmp FSM_edit
0AA6            994   
0AA6            995   ;--------------edit fsm state functions----------------
0AA6            996   
0AA6            997   ; Assumes A register contains the value to be displayed before calling
0AA6            998   ; This routine converts the binary value in A to ASCII and displays it on the LCD
0AA6            999          
0AA6           1000   soaktemp:
0AA6 1206DF    1001            lcall LCD_PB                    ;evaluate the buttons
0AA9 C002      1002            push AR2
0AAB 7A4B      1002            mov R2, #75
0AAD 120154    1002            lcall ?Wait_Milli_Seconds
0AB0 D002      1002            pop AR2         ;need to wait so dont need lightning button presses
0AB2 120AF4    1003            lcall stemp_change
0AB5           1004   
0AB5           1005   Display_soaktemp:
0AB5 C0E0      1006            push acc
0AB7 7401      1006            mov a, #1
0AB9 14        1006            dec a
0ABA 1201E3    1006            lcall ?Set_Cursor_1 ; Select column and row
0ABD D0E0      1006            pop acc                                         ;displaying the values.
0ABF C083      1007            push dph
0AC1 C082      1007            push dpl
0AC3 C0E0      1007            push acc
0AC5 90002E    1007            mov dptr, #param1
0AC8 1201D6    1007            lcall ?Send_Constant_String
0ACB D0E0      1007            pop acc
0ACD D082      1007            pop dpl
0ACF D083      1007            pop dph
0AD1 C0E0      1008            push acc
0AD3 7401      1008            mov a, #1
0AD5 14        1008            dec a
0AD6 1201E1    1008            lcall ?Set_Cursor_2 ; Select column and row
0AD9 D0E0      1008            pop acc
0ADB C000      1009            push ar0
0ADD A849      1009            mov r0, stemp+1
0ADF 1201E8    1009            lcall ?Display_BCD
0AE2 D000      1009            pop ar0
0AE4 C000      1010            push ar0
0AE6 A848      1010            mov r0, stemp+0
0AE8 1201E8    1010            lcall ?Display_BCD
0AEB D000      1010            pop ar0
0AED           1011            
0AED A204      1012            mov c, edit                             ;since is zero when pushed, if carry is on then replay
0AEF 40B5      1013            jc soaktemp
0AF1 020A13    1014            ljmp FSM_soaktemp_done
0AF4           1015   
0AF4           1016   stemp_change:
0AF4           1017       
0AF4 A202      1018            mov c, incr                             ;if increment
0AF6 5005      1019            jnc add_stemp
0AF8 A203      1020            mov c, decr                             ;then check if decrement
0AFA 5010      1021            jnc sub_stemp
0AFC 22        1022            ret
0AFD           1023   
0AFD           1024   add_stemp:
0AFD C3        1025       clr c 
0AFE E548      1026            mov a, stemp+0
0B00 3430      1027       addc a, #0x30
0B02 40B1      1028       jc Display_soaktemp
0B04 E548      1029       mov a, stemp+0              ;need to re add since changed value
0B06 2401      1030            add a, #0x01
0B08 D4        1031            da a
0B09 F548      1032            mov stemp+0, a
0B0B 22        1033            ret
0B0C           1034   
0B0C           1035   sub_stemp:
0B0C C3        1036            clr c
0B0D E548      1037       mov a, stemp+0
0B0F 9431      1038       subb a, #0x31
0B11 40A2      1039       jc Display_soaktemp
0B13 E548      1040       mov a, stemp+0
0B15 2499      1041            add a, #0x99
0B17 D4        1042            da a
0B18 F548      1043            mov stemp+0, a
0B1A 22        1044            ret
0B1B           1045   
0B1B           1046   soaktime:
0B1B 1206DF    1047            lcall LCD_PB                    ;evaluate the buttons
0B1E C002      1048            push AR2
0B20 7A4B      1048            mov R2, #75
0B22 120154    1048            lcall ?Wait_Milli_Seconds
0B25 D002      1048            pop AR2
0B27 120B69    1049            lcall stime_change
0B2A           1050   
0B2A           1051   Display_soaktime:
0B2A C0E0      1052            push acc
0B2C 7401      1052            mov a, #1
0B2E 14        1052            dec a
0B2F 1201E3    1052            lcall ?Set_Cursor_1 ; Select column and row
0B32 D0E0      1052            pop acc                                         ;displaying the values.
0B34 C083      1053            push dph
0B36 C082      1053            push dpl
0B38 C0E0      1053            push acc
0B3A 90003F    1053            mov dptr, #param2
0B3D 1201D6    1053            lcall ?Send_Constant_String
0B40 D0E0      1053            pop acc
0B42 D082      1053            pop dpl
0B44 D083      1053            pop dph
0B46 C0E0      1054            push acc
0B48 7401      1054            mov a, #1
0B4A 14        1054            dec a
0B4B 1201E1    1054            lcall ?Set_Cursor_2 ; Select column and row
0B4E D0E0      1054            pop acc
0B50 C000      1055            push ar0
0B52 7800      1055            mov r0, #0
0B54 1201E8    1055            lcall ?Display_BCD
0B57 D000      1055            pop ar0
0B59 C000      1056            push ar0
0B5B A84A      1056            mov r0, stime
0B5D 1201E8    1056            lcall ?Display_BCD
0B60 D000      1056            pop ar0
0B62           1057   
0B62 A204      1058            mov c, edit                             ;since is zero when pushed, if carry is on then replay 
0B64 40B5      1059            jc soaktime
0B66 020A1F    1060            ljmp FSM_soaktime_done
0B69           1061   
0B69           1062   stime_change:
0B69 A202      1063            mov c, incr                             ;if increment
0B6B 5005      1064            jnc add_stime
0B6D A203      1065            mov c, decr                             ;then check if decrement
0B6F 500B      1066            jnc sub_stime
0B71 22        1067            ret
0B72           1068   
0B72           1069   add_stime:
0B72 E54A      1070       mov a, stime+0              ;need to re add since changed value
0B74 2401      1071            add a, #0x01
0B76 D4        1072            da a
0B77 F54A      1073            mov stime+0, a
0B79 0550      1074            inc stime_bcd
0B7B 22        1075            ret
0B7C           1076   
0B7C           1077   sub_stime:
0B7C E54A      1078       mov a, stime+0
0B7E 2499      1079            add a, #0x99
0B80 D4        1080            da a
0B81 F54A      1081            mov stime+0, a
0B83 1550      1082            dec stime_bcd
0B85 22        1083            ret
0B86           1084   
0B86           1085   
0B86           1086   reflowtemp:
0B86 1206DF    1087            lcall LCD_PB                    ;evaluate the buttons
0B89 C002      1088            push AR2
0B8B 7A4B      1088            mov R2, #75
0B8D 120154    1088            lcall ?Wait_Milli_Seconds
0B90 D002      1088            pop AR2
0B92 120BD4    1089            lcall rtemp_change
0B95           1090            
0B95           1091   Display_reflowtemp:
0B95 C0E0      1092            push acc
0B97 7401      1092            mov a, #1
0B99 14        1092            dec a
0B9A 1201E3    1092            lcall ?Set_Cursor_1 ; Select column and row
0B9D D0E0      1092            pop acc                                         ;displaying the values.
0B9F C083      1093            push dph
0BA1 C082      1093            push dpl
0BA3 C0E0      1093            push acc
0BA5 900050    1093            mov dptr, #param3
0BA8 1201D6    1093            lcall ?Send_Constant_String
0BAB D0E0      1093            pop acc
0BAD D082      1093            pop dpl
0BAF D083      1093            pop dph
0BB1 C0E0      1094            push acc
0BB3 7401      1094            mov a, #1
0BB5 14        1094            dec a
0BB6 1201E1    1094            lcall ?Set_Cursor_2 ; Select column and row
0BB9 D0E0      1094            pop acc
0BBB C000      1095            push ar0
0BBD A84D      1095            mov r0, rtemp+1
0BBF 1201E8    1095            lcall ?Display_BCD
0BC2 D000      1095            pop ar0
0BC4 C000      1096            push ar0
0BC6 A84C      1096            mov r0, rtemp+0
0BC8 1201E8    1096            lcall ?Display_BCD
0BCB D000      1096            pop ar0
0BCD           1097   
0BCD A204      1098            mov c, edit                             ;since is zero when pushed, if carry is on then replay 
0BCF 40B5      1099            jc reflowtemp
0BD1 020A2B    1100            ljmp FSM_reflowtemp_done
0BD4           1101   
0BD4           1102   rtemp_change:
0BD4 A202      1103            mov c, incr                             ;if increment
0BD6 5005      1104            jnc add_rtemp
0BD8 A203      1105            mov c, decr                             ;then check if decrement
0BDA 5009      1106            jnc sub_rtemp
0BDC 22        1107            ret
0BDD           1108   
0BDD           1109   add_rtemp:
0BDD E54C      1110       mov a, rtemp+0              ;need to re add since changed value
0BDF 2401      1111            add a, #0x01
0BE1 D4        1112            da a
0BE2 F54C      1113            mov rtemp+0, a
0BE4 22        1114            ret
0BE5           1115   
0BE5           1116   sub_rtemp:
0BE5 E54C      1117       mov a, rtemp+0
0BE7 2499      1118            add a, #0x99
0BE9 D4        1119            da a
0BEA F54C      1120            mov rtemp+0, a
0BEC 22        1121            ret
0BED           1122   
0BED           1123   reflowtime:
0BED 1206DF    1124            lcall LCD_PB                    ;evaluate the buttons
0BF0 C002      1125            push AR2
0BF2 7A4B      1125            mov R2, #75
0BF4 120154    1125            lcall ?Wait_Milli_Seconds
0BF7 D002      1125            pop AR2
0BF9 120C3B    1126            lcall rtime_change
0BFC           1127            
0BFC           1128   Display_reflowtime:
0BFC C0E0      1129            push acc
0BFE 7401      1129            mov a, #1
0C00 14        1129            dec a
0C01 1201E3    1129            lcall ?Set_Cursor_1 ; Select column and row
0C04 D0E0      1129            pop acc                                         ;displaying the values.
0C06 C083      1130            push dph
0C08 C082      1130            push dpl
0C0A C0E0      1130            push acc
0C0C 900061    1130            mov dptr, #param4
0C0F 1201D6    1130            lcall ?Send_Constant_String
0C12 D0E0      1130            pop acc
0C14 D082      1130            pop dpl
0C16 D083      1130            pop dph
0C18 C0E0      1131            push acc
0C1A 7401      1131            mov a, #1
0C1C 14        1131            dec a
0C1D 1201E1    1131            lcall ?Set_Cursor_2 ; Select column and row
0C20 D0E0      1131            pop acc
0C22 C000      1132            push ar0
0C24 7800      1132            mov r0, #0x00
0C26 1201E8    1132            lcall ?Display_BCD
0C29 D000      1132            pop ar0
0C2B C000      1133            push ar0
0C2D A84E      1133            mov r0, rtime+0
0C2F 1201E8    1133            lcall ?Display_BCD
0C32 D000      1133            pop ar0
0C34           1134   
0C34 A204      1135            mov c, edit                             ;since is zero when pushed, if carry is on then replay 
0C36 40B5      1136            jc reflowtime
0C38 020A37    1137            ljmp FSM_reflowtime_done
0C3B           1138   
0C3B           1139   rtime_change:
0C3B A202      1140            mov c, incr                             ;if increment
0C3D 5005      1141            jnc add_rtime
0C3F A203      1142            mov c, decr                             ;then check if decrement
0C41 500B      1143            jnc sub_rtime
0C43 22        1144            ret
0C44           1145   
0C44           1146   add_rtime:
0C44 E54E      1147       mov a, rtime+0              ;need to re add since changed value
0C46 2401      1148            add a, #0x01
0C48 D4        1149            da a
0C49 F54E      1150            mov rtime+0, a
0C4B 0552      1151            inc rtime_bcd
0C4D 22        1152            ret
0C4E           1153   
0C4E           1154   sub_rtime:
0C4E E54E      1155       mov a, rtime+0
0C50 2499      1156            add a, #0x99
0C52 D4        1157            da a
0C53 F54E      1158            mov rtime+0, a
0C55 0552      1159            inc rtime_bcd
0C57 22        1160            ret
0C58           1161   ;------------------------------------------------------
0C58           1162   
0C58           1163   EN
