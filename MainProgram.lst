0000              1   ; main program to be run 
                  3   $LIST
0000              5   
0000              6   ;  N76E003 pinout:
0000              7   ;                               -------
0000              8   ;       PWM2/IC6/T0/AIN4/P0.5 -|1    20|- P0.4/AIN5/STADC/PWM3/IC3
0000              9   ;               TXD/AIN3/P0.6 -|2    19|- P0.3/PWM5/IC5/AIN6
0000             10   ;               RXD/AIN2/P0.7 -|3    18|- P0.2/ICPCK/OCDCK/RXD_1/[SCL]
0000             11   ;                    RST/P2.0 -|4    17|- P0.1/PWM4/IC4/MISO
0000             12   ;        INT0/OSCIN/AIN1/P3.0 -|5    16|- P0.0/PWM3/IC3/MOSI/T1
0000             13   ;              INT1/AIN0/P1.7 -|6    15|- P1.0/PWM2/IC2/SPCLK
0000             14   ;                         GND -|7    14|- P1.1/PWM1/IC1/AIN7/CLO
0000             15   ;[SDA]/TXD_1/ICPDA/OCDDA/P1.6 -|8    13|- P1.2/PWM0/IC0
0000             16   ;                         VDD -|9    12|- P1.3/SCL/[STADC]
0000             17   ;            PWM5/IC7/SS/P1.5 -|10   11|- P1.4/SDA/FB/PWM1
0000             18   ;                               -------
0000             19   ;
0000             20   
0000             21   ;----------------clock values---------------------
0000             22   CLK               EQU 16600000 ; Microcontroller system frequency in Hz
0000             23   BAUD              EQU 115200 ; Baud rate of UART in bps
0000             24   TIMER1_RELOAD     EQU (0x100-(CLK/(16*BAUD)))
0000             25   TIMER0_RATE              EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             26   
0000             27   TIMER0_RELOAD            EQU ((65536-(CLK/TIMER0_RATE)))
0000             28   TIMER2_RATE         EQU 1000    ; 1000Hz, for a timer tick of 1ms
0000             29   TIMER2_RELOAD            EQU ((65536-(CLK/TIMER2_RATE)))
0000             30   
0000             31   PAGE_ERASE_AP   EQU 00100010b    ;for flash memory
0000             32   BYTE_PROGRAM_AP EQU 00100001b
0000             33   
0000             34   ORG 0x0000
0000 02074B      35            ljmp MainProgram
0003             36   
0003             37   ; External interrupt 0 vector (not used in this code)
0003             38   org 0x0003
0003 32          39            reti
0004             40   
0004             41   ; Timer/Counter 0 overflow interrupt vector
000B             42   org 0x000B
000B 02057B      43            ljmp Timer0_ISR
000E             44   
000E             45   ; External interrupt 1 vector (not used in this code)
0013             46   org 0x0013
0013 32          47            reti
0014             48   
0014             49   ; Timer/Counter 1 overflow interrupt vector (not used in this code)
001B             50   org 0x001B
001B 32          51            reti
001C             52   
001C             53   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             54   org 0x0023 
0023 32          55            reti
0024             56            
0024             57   ; Timer/Counter 2 overflow interrupt vector
002B             58   org 0x002B
002B 0205A3      59            ljmp Timer2_ISR
002E             60   
002E             61   
002E             62   ;               1234567890123456    <- This helps determine the location of the counter
002E 534F414B    63   param1:     db 'SOAK TEMP:      ', 0
     2054454D
     503A2020
     20202020
     00
003F 534F414B    64   param2:     db 'SOAK TIME:      ', 0
     2054494D
     453A2020
     20202020
     00
0050 5245464C    65   param3:     db 'REFLOW TEMP:    ', 0
     4F572054
     454D503A
     20202020
     00
0061 5245464C    66   param4:     db 'REFLOW TIME:     ', 0
     4F572054
     494D453A
     20202020
     2000
0073 2D3E5354    67   startmsg:     db '->START 2 START  ', 0
     41525420
     32205354
     41525420
     2000
0085 2D3E4544    68   editmsg:     db '->EDIT 2 EDIT    ', 0
     49542032
     20454449
     54202020
     2000
0097 434F4E46    69   title06:     db 'CONFIRM?           ', 0
     49524D3F
     20202020
     20202020
     20202000
00AB 5245464C    70   title07:     db 'REFLOW TIME?       ', 0
     4F572054
     494D453F
     20202020
     20202000
00BF 434F4E46    71   title08:     db 'CONFIRM?           ', 0
     49524D3F
     20202020
     20202020
     20202000
00D3 31205241    72   title1:     db '1 RAMP   Ts:       ', 0
     4D502020
     2054733A
     20202020
     20202000
00E7 3220534F    73   title2:     db '2 SOAK             ', 0
     414B2020
     20202020
     20202020
     20202000
00FB 33205241    74   title3:     db '3 RAMP   Tr:       ', 0
     4D502020
     2054723A
     20202020
     20202000
010F 34205245    75   title4:     db '4 REFLOW           ', 0
     464C4F57
     20202020
     20202020
     20202000
0123 3520434F    76   title5:     db '5 COOLING          ', 0
     4F4C494E
     47202020
     20202020
     20202000
0137 20202020    77   blank:     db '                  ', 0
     20202020
     20202020
     20202020
     202000
014A             78   
014A             79   cseg
014A             80   ; These 'equ' must match the hardware wiring
014A             81   LCD_RS equ P1.3
014A             82   LCD_E  equ P1.4
014A             83   LCD_D4 equ P0.0
014A             84   LCD_D5 equ P0.1
014A             85   LCD_D6 equ P0.2
014A             86   LCD_D7 equ P0.3
014A             87   
014A             88   PWM_OUT     equ P1.0 ; logic=1 oven on
014A             89   SOUND_OUT        equ P1.6
014A             90   
014A             91   ;-------------------------------------------------------
0030             92   DSEG at 0x30
0030             93   
0030             94   ;---------------temp validation----------------------
0030             95   
0030             96   x:   ds 4
0034             97   y:   ds 4
0038             98   bcd: ds 5
003D             99   VLED_ADC: ds 2
003F            100   
003F            101   
003F            102   ;----------------- clock and speaker ------------------------------
003F            103   Count1ms:               ds 2 ;to determine when one second has passed
0041            104   secs_ctr:               ds 1
0042            105   mins_ctr:               ds 1
0043            106   
0043            107   
0043            108   state_secs_ctr:                  ds 2
0045            109   
0045            110   buzzer:                                  ds 1
0046            111   
0046            112   ;-----------------FSM-s-------------------
0046            113   FSM1_state:             ds 1 ; determine state
0047            114   edit_state:                              ds 1
0048            115   
0048            116   ;----------------fsm values--------------------
0048            117   stemp:                                   ds 2
004A            118   stime:                                   ds 2
004C            119   rtemp:                                   ds 2
004E            120   rtime:                                   ds 2
0050            121   stime_bcd:                               ds 2
0052            122   rtime_bcd:                               ds 2
0054            123   
0054            124   ;-----------------timer values-----------------
0054            125   soak_timer:             ds 2
0056            126   reflow_timer:           ds 1
0057            127   
0057            128   ;----------------PWM-----------------
0057            129   pwm_counter:            ds 1
0058            130   pwm:                    ds 1
0059            131   
0059            132   ;------------------oven temp-------------
0059            133   oven_temp:                               ds 2
005B            134   
005B            135   
005B            136   ;-------------------flags-----------------------------
0000            137   BSEG 
0000            138   mf: dbit 1
0001            139   one_second_flag: dbit 1
0002            140   
0002            141   ;----------------push buttons------------------
0002            142   incr:                    dbit 1
0003            143   decr:                    dbit 1
0004            144   edit:                    dbit 1
0005            145   reset:                   dbit 1
0006            146   start_stop:              dbit 1
0007            147   
0007            148   ;---------------soak and reflow time flag-------------
0007            149   soak_timer_flag:    dbit 1
0008            150   reflow_timer_flag:  dbit 1
0009            151   soak_temp_flag:    dbit 1
000A            152   reflow_temp_flag:  dbit 1
000B            153   ;--------------PWM flag---------------------
000B            154   pwm_flag:           dbit 1
000C            155   
                546   $LIST
                158   $LIST
046E            160   ;---------flash memory functions-------------
046E            161   putchar:
046E 3099FD     162       JNB TI, putchar
0471 C299       163       CLR TI
0473 F599       164       MOV SBUF, a
0475 22         165       RET
0476            166   
0476            167   SendString:
0476 E4         168       CLR A
0477 93         169       MOVC A, @A+DPTR
0478 6006       170       JZ SSDone
047A 12046E     171       LCALL putchar
047D A3         172       INC DPTR
047E 80F6       173       SJMP SendString
0480            174   SSDone:
0480 22         175       ret
0481            176   
0481            177   ; Sends the byte in the accumulator to the serial port in decimal 
0481            178   Send_byte:
0481 75F064     179            mov b, #100
0484 84         180            div ab
0485 4430       181            orl a, #'0'
0487 12046E     182            lcall putchar
048A E5F0       183            mov a, b
048C 75F00A     184            mov b, #10
048F 84         185            div ab
0490 4430       186            orl a, #'0'
0492 12046E     187            lcall putchar
0495 E5F0       188            mov a, b
0497 4430       189            orl a, #'0'
0499 12046E     190            lcall putchar
049C 740D       191            mov a, #'\r'
049E 12046E     192            lcall putchar
04A1 740A       193            mov a, #'\n'
04A3 12046E     194            lcall putchar
04A6 22         195            ret
04A7            196   
04A7            197   ;---------------------------------;
04A7            198   ; Routine to initialize the pins  ;
04A7            199   ; for input out - ADC inc         ;
04A7            200   ;---------------------------------;
04A7            201   Init_All:
04A7            202            ; Configure all the pins for biderectional I/O
04A7 75AC00     203            mov     P3M1, #0x00
04AA 75AD00     204            mov     P3M2, #0x00
04AD 75B300     205            mov     P1M1, #0x00
04B0 75B400     206            mov     P1M2, #0x00
04B3 75B100     207            mov     P0M1, #0x00
04B6 75B200     208            mov     P0M2, #0x00
04B9            209            
04B9 438E10     210            orl     CKCON, #0x10 ; CLK is the input for timer 1
04BC 438780     211            orl     PCON, #0x80 ; Bit SMOD=1, double baud rate
04BF 759852     212            mov     SCON, #0x52
04C2 53C4DF     213            anl     T3CON, #0b11011111
04C5 53890F     214            anl     TMOD, #0x0F ; Clear the configuration bits for timer 1
04C8 438920     215            orl     TMOD, #0x20 ; Timer 1 Mode 2
04CB 758DF7     216            mov     TH1, #TIMER1_RELOAD ; TH1=TIMER1_RELOAD;
04CE D28E       217            setb TR1
04D0            218            
04D0 759852     219            mov SCON, #52H
04D3            220            
04D3            221            
04D3            222            ; Using timer 0 for delay functions.  Initialize here:
04D3 C28C       223            clr     TR0 ; Stop timer 0
04D5 438E08     224            orl     CKCON,#0x08 ; CLK is the input for timer 0
04D8 5389F0     225            anl     TMOD,#0xF0 ; Clear the configuration bits for timer 0
04DB 438901     226            orl     TMOD,#0x01 ; Timer 0 in Mode 1: 16-bit timer
04DE            227            
04DE            228            ; Initialize the pins used by the ADC (P1.1, P1.7) as input.
04DE 43B382     229            orl     P1M1, #0b10000010
04E1 53B47D     230            anl     P1M2, #0b01111101
04E4            231            
04E4            232            ; Since the reset button bounces, we need to wait a bit before
04E4            233       ; sending messages, otherwise we risk displaying gibberish!
04E4 79C8       234            mov R1, #200
04E6 7868       235       mov R0, #104
04E8 D8FE       236       djnz R0, $   ; 4 cycles->4*60.285ns*104=25us
04EA D9FA       237       djnz R1, $-4 ; 25us*200=5.0ms
04EC            238            
04EC            239            ; Initialize and start the ADC:
04EC 53E8F0     240            anl ADCCON0, #0xF0
04EF 43E807     241            orl ADCCON0, #0x07 ; Select channel 7
04F2            242            ; AINDIDS select if some pins are analog inputs or digital I/O:
04F2 75F600     243            mov AINDIDS, #0x00 ; Disable all analog inputs
04F5 43F681     244            orl AINDIDS, #0b10000001 ; Activate AIN0 and AIN7 analog inputs
04F8 43E101     245            orl ADCCON1, #0x01 ; Enable ADC
04FB            246            
04FB 22         247            ret
04FC            248   
04FC            249   ;-----------functions for temp reading ADC-----------
04FC            250   Read_ADC:
04FC C2EF       251            clr ADCF
04FE D2EE       252            setb ADCS ;  ADC start trigger signal
0500 30EFFD     253       jnb ADCF, $ ; Wait for conversion complete
0503            254       
0503            255       ; Read the ADC result and store in [R1, R0]
0503 E5C2       256       mov a, ADCRL
0505 540F       257       anl a, #0x0f
0507 F8         258       mov R0, a
0508 E5C3       259       mov a, ADCRH   
050A C4         260       swap a
050B C0E0       261       push acc
050D 540F       262       anl a, #0x0f
050F F9         263       mov R1, a
0510 D0E0       264       pop acc
0512 54F0       265       anl a, #0xf0
0514 48         266       orl a, R0
0515 F8         267       mov R0, A
0516 22         268            ret
0517            269   
                270   Send_BCD mac
                271   	push ar0
                272   	mov r0, %0
                273   	lcall ?Send_BCD
                274   	pop ar0
                275   	endmac
0517            276            
0517            277            ?Send_BCD:
0517 C0E0       278            push acc
0519            279            ; Write most significant digit
0519 E8         280            mov a, r0
051A C4         281            swap a
051B 540F       282            anl a, #0fh
051D 4430       283            orl a, #30h
051F 12046E     284            lcall putchar
0522            285            ; write least significant digit
0522 E8         286            mov a, r0
0523 540F       287            anl a, #0fh
0525 4430       288            orl a, #30h
0527 12046E     289            lcall putchar
052A D0E0       290            pop acc
052C 22         291            ret
052D            292   
                293   	SendChar mac
                294   	push acc
                295   	mov a,%0
                296   	lcall putchar
                297   	pop acc
                298   	endmac
052D            299   
052D            300   Display_formated_BCD:
052D C0E0       301            push acc
052F 7401       301            mov a, #1
0531 14         301            dec a
0532 1201E1     301            lcall ?Set_Cursor_2 ; Select column and row
0535 D0E0       301            pop acc
0537 C000       302            push ar0
0539 A83B       302            mov r0, bcd+3
053B 1201E8     302            lcall ?Display_BCD
053E D000       302            pop ar0
0540 C000       303            push ar0
0542 A83A       303            mov r0, bcd+2
0544 1201E8     303            lcall ?Display_BCD
0547 D000       303            pop ar0
0549 C0E0       304            push acc
054B 742E       304            mov a, #'.'
054D 120199     304            lcall ?WriteData
0550 D0E0       304            pop acc
0552 C000       305            push ar0
0554 A839       305            mov r0, bcd+1
0556 1201E8     305            lcall ?Display_BCD
0559 D000       305            pop ar0
055B C000       306            push ar0
055D A838       306            mov r0, bcd+0
055F 1201E8     306            lcall ?Display_BCD
0562 D000       306            pop ar0
0564            307   
0564 22         308            ret
0565            309   ;---------------------------------;
0565            310   ; Routine to initialize the ISR   ;
0565            311   ; for timer 0                     ;
0565            312   ;---------------------------------;
0565            313   Timer0_Init:
0565 438E08     314            orl CKCON, #0b00001000 ; Input for timer 0 is sysclk/1
0568 E589       315            mov a, TMOD
056A 54F0       316            anl a, #0xf0 ; 11110000 Clear the bits for timer 0
056C 4401       317            orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
056E F589       318            mov TMOD, a
0570 758CF0     319            mov TH0, #high(TIMER0_RELOAD)
0573 758A2C     320            mov TL0, #low(TIMER0_RELOAD)
0576            321            ; Enable the timer and interrupts
0576 D2A9       322       setb ET0  ; Enable timer 0 interrupt
0578 D28C       323       setb TR0  ; Start timer 0
057A 22         324            ret
057B            325   
057B            326   ;---------------------------------;
057B            327   ; ISR for timer 0.  Set to execute;
057B            328   ; every 1/4096Hz to generate a    ;
057B            329   ; 2048 Hz wave at pin SOUND_OUT   ;
057B            330   ;---------------------------------;
057B            331   Timer0_ISR:
057B            332            ;clr TF0  ; According to the data sheet this is done for us already.
057B            333            ; Timer 0 doesn't have 16-bit auto-reload, so
057B C28C       334            clr TR0
057D 758CF0     335            mov TH0, #high(TIMER0_RELOAD)
0580 758A2C     336            mov TL0, #low(TIMER0_RELOAD)
0583 D28C       337            setb TR0
0585 B296       338            cpl SOUND_OUT   
0587 32         339            reti
0588            340   
0588            341   ;---------------------------------;
0588            342   ; Routine to initialize the ISR   ;
0588            343   ; for timer 2                     ;
0588            344   ;---------------------------------;
0588            345   Timer2_Init:
0588 75C800     346            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.z
058B 75CDBF     347            mov TH2, #high(TIMER2_RELOAD)
058E 75CC28     348            mov TL2, #low(TIMER2_RELOAD)
0591            349            ; Set the reload value
0591 43C980     350            orl T2MOD, #0x80 ; Enable timer 2 autoreload
0594 75CBBF     351            mov RCMP2H, #high(TIMER2_RELOAD)
0597 75CA28     352            mov RCMP2L, #low(TIMER2_RELOAD)
059A            353            ; Init One millisecond interrupt counter.  It is a 16-bit variable made with two 8-bit parts
059A E4         354            clr a
059B F53F       355            mov Count1ms+0, a
059D F540       356            mov Count1ms+1, a
059F            357            ; Enable the timer and interrupts
059F 439B80     358            orl EIE, #0x80 ; Enable timer 2 interrupt ET2=1
05A2            359       ;setb TR2  ; Enable timer 2
05A2 22         360            ret
05A3            361   
05A3            362   ;---------------------------------;
05A3            363   ; ISR for timer 2                 ;
05A3            364   ;---------------------------------;
05A3            365   Timer2_ISR:
05A3 C2CF       366            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in the ISR.  It is bit addressable.
05A5 B284       367            cpl P0.4 ; To check the interrupt rate with oscilloscope. It must be precisely a 1 ms pulse.
05A7            368            
05A7            369            ; The two registers used in the ISR must be saved in the stack
05A7 C0E0       370            push acc
05A9 C0D0       371            push psw
05AB            372            
05AB            373            ; Increment the 16-bit one mili second counter
05AB 053F       374            inc Count1ms+0    ; Increment the low 8-bits first
05AD E53F       375            mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
05AF 7014       376            jnz Inc_Done
05B1 0540       377            inc Count1ms+1
05B3            378            ;mov a, buzzer
05B3            379            ;cjne a, #0, buzzer_out
05B3            380   
05B3            381   pwm_counts:
05B3            382       
05B3 0557       383       inc pwm_counter
05B5 C3         384       clr c
05B6 E558       385       mov a, pwm
05B8 9557       386       subb a, pwm_counter ;If pwm_counter <= pwm then c=1
05BA B3         387            cpl c
05BB 9290       388            mov PWM_OUT, c
05BD            389            
05BD E557       390       mov a, pwm_counter
05BF B46403     391            cjne a, #100, Inc_Done
05C2 755700     392            mov pwm_counter, #0
05C5            393   
05C5            394   
05C5            395   Inc_Done:
05C5            396            ; Check if half second has passed
05C5 E53F       397            mov a, Count1ms+0
05C7 B4E814     398            cjne a, #low(1000), jumper ; Warning: this instruction changes the carry flag!
05CA E540       399            mov a, Count1ms+1
05CC B4032B     400            cjne a, #high(1000), Timer2_ISR_done
05CF            401            
05CF            402            ; 500 milliseconds have passed.  Set a flag so the main program knows
05CF D201       403            setb one_second_flag; Let the main program know half second had passed
05D1 B28C       404            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
05D3            405            ; Reset to zero the milli-seconds counter, it is a 16-bit variable
05D3 E4         406            clr a
05D4 F53F       407            mov Count1ms+0, a
05D6 F540       408            mov Count1ms+1, a
05D8            409            ; Increment the BCD counter
05D8 E541       410            mov a, secs_ctr
05DA            411            ;jnb UPDOWN, Timer2_ISR_decrement
05DA 2401       412            add a, #0x01
05DC 8003       413            sjmp clkup
05DE            414            
05DE            415   jumper:
05DE 0205FA     416            ljmp Timer2_ISR_done
05E1            417   
05E1            418   ; clkup:
05E1            419   ;        mov a, state_secs_ctr                                           ;variables for state timers
05E1            420   ;        add a, #1
05E1            421   ;        da a
05E1            422   ;        mov state_secs_ctr, a
05E1            423   ;        mov a, secs_ctr
05E1            424   ;        add a, #1
05E1            425   ;        da a ; Decimal adjust instruction.  Check datasheet for more details!
05E1            426   ;        mov secs_ctr, a
05E1            427   ;        cjne a, #0x60, Timer2_ISR_done
05E1            428   ;        mov secs_ctr, #0x00
05E1            429   ;        mov a, mins_ctr
05E1            430   ;        add a, #1
05E1            431   ;        da a
05E1            432   ;        mov mins_ctr, a
05E1            433   
05E1            434   clkup:
05E1 E543       435            mov a, state_secs_ctr   
05E3 04         436            inc a   ;variables for state timers
05E4 D4         437            da a
05E5 F543       438            mov state_secs_ctr, a
05E7 E541       439            mov a, secs_ctr
05E9 2401       440            add a, #0x01
05EB D4         441            da a
05EC F541       442            mov secs_ctr, a
05EE B46009     443            cjne a, #0x60, Timer2_ISR_done
05F1 754100     444            mov secs_ctr, #0x00
05F4 E542       445            mov a, mins_ctr
05F6 04         446            inc a                                    ; Decimal adjust instruction.  Check datasheet for more details!
05F7 D4         447            da a
05F8 F542       448            mov mins_ctr, a
05FA            449   
05FA            450   
05FA            451   Timer2_ISR_done:
05FA D0D0       452            pop psw
05FC D0E0       453            pop acc
05FE 32         454            reti
05FF            455   
05FF            456   
05FF            457   ;-------------------Generate Display--------------------------
05FF            458   GenerateDisplay:
05FF            459   
05FF            460   MtimerDisplay:
05FF            461   
05FF C0E0       462            push acc
0601 740F       462            mov a, #15
0603 14         462            dec a
0604 1201E1     462            lcall ?Set_Cursor_2 ; Select column and row
0607 D0E0       462            pop acc
0609 C000       463            push ar0
060B A841       463            mov r0, secs_ctr
060D 1201E8     463            lcall ?Display_BCD
0610 D000       463            pop ar0
0612 C0E0       464            push acc
0614 740E       464            mov a, #14
0616 14         464            dec a
0617 1201E1     464            lcall ?Set_Cursor_2 ; Select column and row
061A D0E0       464            pop acc
061C C0E0       465            push acc
061E 743A       465            mov a, #':'
0620 120199     465            lcall ?WriteData
0623 D0E0       465            pop acc
0625 C0E0       466            push acc
0627 740C       466            mov a, #12
0629 14         466            dec a
062A 1201E1     466            lcall ?Set_Cursor_2 ; Select column and row
062D D0E0       466            pop acc
062F C000       467            push ar0
0631 A842       467            mov r0, mins_ctr
0633 1201E8     467            lcall ?Display_BCD
0636 D000       467            pop ar0
0638            468   
0638            469   TempDisplay:
0638 C0E0       470            push acc
063A 7401       470            mov a, #1
063C 14         470            dec a
063D 1201E1     470            lcall ?Set_Cursor_2 ; Select column and row
0640 D0E0       470            pop acc
0642            471            ; Read the 2.08V LED voltage connected to AIN0 on pin 6
0642 53E8F0     472            anl ADCCON0, #0xF0
0645 43E800     473            orl ADCCON0, #0x00 ; Select channel 0
0648            474   
0648 1204FC     475            lcall Read_ADC
064B            476            ; Save result for later use
064B 883D       477            mov VLED_ADC+0, R0
064D 893E       478            mov VLED_ADC+1, R1
064F            479   
064F            480            ; Read the signal connected to AIN7
064F 53E8F0     481            anl ADCCON0, #0xF0
0652 43E807     482            orl ADCCON0, #0x07 ; Select channel 7
0655 1204FC     483            lcall Read_ADC
0658            484       
0658            485       ; Convert to voltage
0658 8830       486            mov x+0, R0
065A 8931       487            mov x+1, R1
065C            488            ; Pad other bits with zero
065C 753200     489            mov x+2, #0
065F 753300     490            mov x+3, #0
0662 753404     491            mov y+0, #low (20740 % 0x10000) 
0665 753551     491            mov y+1, #high(20740 % 0x10000) 
0668 753600     491            mov y+2, #low (20740 / 0x10000) 
066B 753700     491            mov y+3, #high(20740 / 0x10000)  ; The MEASURED LED voltage: 2.074V, with 4 decimal places
066E 120378     492            lcall mul32
0671            493            ; Retrive the ADC LED value
0671 853D34     494            mov y+0, VLED_ADC+0
0674 853E35     495            mov y+1, VLED_ADC+1
0677            496            ; Pad other bits with zero
0677 753600     497            mov y+2, #0
067A 753700     498            mov y+3, #0
067D 120405     499            lcall div32
0680            500            
0680            501   
0680 75344A     502            mov y+0, #low (74 % 0x10000) 
0683 753500     502            mov y+1, #high(74 % 0x10000) 
0686 753600     502            mov y+2, #low (74 / 0x10000) 
0689 753700     502            mov y+3, #high(74 / 0x10000) 
068C 120378     503            lcall mul32
068F 753498     504            mov y+0, #low (207000 % 0x10000) 
0692 753528     504            mov y+1, #high(207000 % 0x10000) 
0695 753603     504            mov y+2, #low (207000 / 0x10000) 
0698 753700     504            mov y+3, #high(207000 / 0x10000)   
069B 1202C3     505            lcall add32
069E            506       ; x is vCH 
069E            507       ; Load_y(27300) ;load 2.73V into y
069E            508       ; lcall sub32
069E            509       ; Load_y(100)
069E            510       ;lcall mul32
069E            511       ;x is now T
069E            512            ; Convert to BCD and display
069E 1201FE     513            lcall hex2bcd
06A1 12052D     514            lcall Display_formated_BCD
06A4            515            
06A4 C000       516            push ar0
06A6 A83B       516            mov r0, bcd+3
06A8 120517     516            lcall ?Send_BCD
06AB D000       516            pop ar0
06AD C000       517            push ar0
06AF A83A       517            mov r0, bcd+2
06B1 120517     517            lcall ?Send_BCD
06B4 D000       517            pop ar0
06B6 C0E0       518            push acc
06B8 742E       518            mov a,#'.'
06BA 12046E     518            lcall putchar
06BD D0E0       518            pop acc
06BF C000       519            push ar0
06C1 A839       519            mov r0, bcd+1
06C3 120517     519            lcall ?Send_BCD
06C6 D000       519            pop ar0
06C8 C000       520            push ar0
06CA A838       520            mov r0, bcd+0
06CC 120517     520            lcall ?Send_BCD
06CF D000       520            pop ar0
06D1 C0E0       521            push acc
06D3 740A       521            mov a,#'\n'
06D5 12046E     521            lcall putchar
06D8 D0E0       521            pop acc
06DA            522   
06DA 853A59     523            mov oven_temp+0, bcd+2                  ;saving the oven temp
06DD 853B5A     524            mov oven_temp+1, bcd+3
06E0            525   
06E0 22         526            ret
06E1            527   
06E1            528   ;-----------------lcd pushbuttons--------------------------
06E1            529   LCD_PB:
06E1            530            ; Set variables to 1: 'no push button pressed'
06E1 D202       531            setb incr
06E3 D203       532            setb decr
06E5 D204       533            setb edit
06E7 D206       534            setb start_stop
06E9 D205       535            setb reset
06EB            536            ; The input pin used to check set to '1'
06EB D295       537            setb P1.5
06ED            538            
06ED            539            ; Check if any push button is pressed
06ED C280       540            clr P0.0
06EF C281       541            clr P0.1
06F1 C282       542            clr P0.2
06F3 C283       543            clr P0.3
06F5 C293       544            clr P1.3
06F7 20953A     545            jb P1.5, LCD_PB_Done
06FA            546   
06FA            547            ; Debounce
06FA 7A32       548            mov R2, #50
06FC 120745     549            lcall waitms
06FF 209532     550            jb P1.5, LCD_PB_Done
0702            551   
0702            552            ; Set the LCD data pins to logic 1
0702 D280       553            setb P0.0
0704 D281       554            setb P0.1
0706 D282       555            setb P0.2
0708 D283       556            setb P0.3
070A D293       557            setb P1.3
070C            558            
070C            559            ; Check the push buttons one by one
070C C293       560            clr P1.3
070E A295       561            mov c, P1.5
0710 9205       562            mov reset, c
0712 D293       563            setb P1.3
0714            564   
0714 C280       565            clr P0.0
0716 A295       566            mov c, P1.5
0718 9206       567            mov start_stop, c
071A D280       568            setb P0.0
071C            569            
071C C281       570            clr P0.1
071E A295       571            mov c, P1.5
0720 9204       572            mov edit, c
0722 D281       573            setb P0.1
0724            574            
0724 C282       575            clr P0.2
0726 A295       576            mov c, P1.5
0728 9203       577            mov decr, c
072A D282       578            setb P0.2
072C            579            
072C C283       580            clr P0.3
072E A295       581            mov c, P1.5
0730 9202       582            mov incr, c
0732 D283       583            setb P0.3
0734            584   
0734            585   LCD_PB_Done:             
0734 22         586            ret
0735            587   
0735            588   wait_1ms:
0735 C28C       589            clr     TR0 ; Stop timer 0
0737 C28D       590            clr     TF0 ; Clear overflow flag
0739 758CF0     591            mov     TH0, #high(TIMER0_RELOAD)
073C 758A2C     592            mov     TL0,#low(TIMER0_RELOAD)
073F D28C       593            setb TR0
0741 308DFD     594            jnb     TF0, $ ; Wait for overflow
0744 22         595            ret
0745            596   
0745            597   ; Wait the number of miliseconds in R2
0745            598   waitms:
0745 120735     599            lcall wait_1ms
0748 DAFB       600            djnz R2, waitms
074A 22         601            ret
074B            602   
074B            603   ;--------------------------------- Main Program --------------------------------
074B            604   
074B            605   MainProgram:                            ;main program
074B            606       
074B 75817F     607       mov SP, #0x7f
074E 1204A7     608       lcall Init_All
0751 1201A3     609       lcall LCD_4BIT                                        ; initialize settings
0754            610   
0754 C201       611       clr one_second_flag     
0756 C207       612       clr soak_timer_flag                               ; flags
0758 C208       613       clr reflow_timer_flag
075A C20B       614       clr pwm_flag
075C            615   
075C 754600     616       mov FSM1_state, #0
075F 754700     617            mov edit_state, #0
0762            618                                                ; fsm
0762 754100     619       mov secs_ctr, #0                                    ; clock
0765 754200     620       mov mins_ctr, #0
0768 755400     621       mov soak_timer, #0
076B 755600     622       mov reflow_timer, #0
076E 754500     623            mov buzzer, #0
0771 755700     624            mov pwm_counter, #0
0774            625                                           ; edit settings
0774            626       ;lcall Timer1_Init                                    ; timers
0774 120588     627       lcall Timer2_Init
0777            628            
0777 D2CA       629            setb TR2
0779 D2AF       630       setb EA
077B            631   
077B            632   
077B            633   
077B 754850     634       mov stemp+0, #0x50
077E 754901     635            mov stemp+1, #0x01
0781 754A60     636            mov stime, #0x60
0784 E54A       637            mov a, stime
0786 D4         638            da a 
0787 F550       639            mov stime_bcd, a
0789 754C17     640            mov rtemp+0, #0x17
078C 754D02     641       mov rtemp+1, #0x02
078F 754E45     642            mov rtime, #0x45
0792 E54E       643            mov a, rtime
0794 D4         644            da a 
0795 F552       645            mov rtime_bcd, a
0797            646       
0797            647                                           ; 
0797            648   
0797            649   forever:  
0797 300105     650       jnb one_second_flag, SkipDisplay            ;every second, the screen should update
079A C201       651       clr one_second_flag
079C 1205FF     652       lcall GenerateDisplay 
079F            653            
079F            654   
079F            655   SkipDisplay:                                    ;if no display needed
079F            656                                                     
079F 020856     657            ljmp FSM1
07A2            658   ;-----------------------------------------------------------------
07A2            659   
07A2            660   ;-----------------------check_stop_restart-----------------------
07A2            661   check_stop_restart:
07A2 1206E1     662            lcall LCD_PB                            ;evaluate the buttons   ;need to wait so dont need lightning button presses
07A5 A206       663            mov c, start_stop
07A7 5005       664            jnc stop_protocol
07A9 A205       665            mov c, reset
07AB 5008       666            jnc reset_protocol
07AD 22         667            ret
07AE            668   
07AE            669   stop_protocol:
07AE 755800     670            mov pwm, #0
07B1 754600     671            mov FSM1_state, #0
07B4 22         672            ret
07B5            673   
07B5            674   reset_protocol:
07B5 755800     675            mov pwm, #0                                     ;turn off oven
07B8 754600     676            mov FSM1_state, #0                      ;go back to select stage
07BB 22         677            ret
07BC            678   
07BC            679   
07BC            680   ;----------------------------load functions to compare values------
07BC            681   load_soak_temp:
07BC C0E0       682            push acc
07BE C0D0       683            push psw
07C0 C200       684            clr mf
07C2 E4         685            clr A
07C3            686   
07C3 F530       687            mov x+0,a
07C5 F531       688            mov x+1,a
07C7 F532       689            mov x+2,a
07C9 F533       690            mov x+3,a
07CB            691            
07CB F534       692            mov y+0,a
07CD F535       693            mov y+1,a
07CF F536       694            mov y+2,a
07D1 F537       695            mov y+3,a
07D3            696            
07D3            697   
07D3 854830     698            mov x+0, stemp+0
07D6 854931     699            mov x+1, stemp+1
07D9            700            
07D9 855934     701            mov y+0, oven_temp+0
07DC 855A35     702            mov y+1, oven_temp+1
07DF            703            
07DF D0D0       704            pop psw
07E1 D0E0       705            pop acc
07E3 22         706            ret
07E4            707   
07E4            708   load_reflow_temp:
07E4 C0E0       709            push acc
07E6 C0D0       710            push psw
07E8 C200       711            clr mf
07EA E4         712            clr a
07EB            713            
07EB F530       714            mov x+0,a
07ED F531       715            mov x+1,a
07EF F532       716            mov x+2,a
07F1 F533       717            mov x+3,a
07F3            718            
07F3 F534       719            mov y+0,a
07F5 F535       720            mov y+1,a
07F7 F536       721            mov y+2,a
07F9 F537       722            mov y+3,a
07FB            723            
07FB            724   
07FB 854C30     725            mov x+0, rtemp+0
07FE 854D31     726            mov x+1, rtemp+1
0801            727            
0801 855934     728            mov y+0, oven_temp+0
0804 855A35     729            mov y+1, oven_temp+1
0807            730            
0807 D0D0       731            pop psw
0809 D0E0       732            pop acc
080B 22         733            ret
080C            734   
080C            735   load_abort_temp:
080C C0E0       736            push acc
080E C0D0       737            push psw
0810 C200       738            clr mf
0812 E4         739            clr a
0813            740            
0813 F530       741            mov x+0,a
0815 F531       742            mov x+1,a
0817 F532       743            mov x+2,a
0819 F533       744            mov x+3,a
081B            745            
081B F534       746            mov y+0,a
081D F535       747            mov y+1,a
081F F536       748            mov y+2,a
0821 F537       749            mov y+3,a
0823            750   
0823 753050     751            mov x+0, #0x50
0826            752            
0826 855934     753            mov y+0, oven_temp+0
0829 855A35     754            mov y+1, oven_temp+1
082C            755   
082C D0D0       756            pop psw
082E D0E0       757            pop acc
0830 22         758            ret
0831            759   
0831            760   load_cooling_temp:
0831 C0E0       761            push acc
0833 C0D0       762            push psw
0835 C200       763            clr mf
0837 E4         764            clr a
0838            765            
0838 F530       766            mov x+0,a
083A F531       767            mov x+1,a
083C F532       768            mov x+2,a
083E F533       769            mov x+3,a
0840            770            
0840 F534       771            mov y+0,a
0842 F535       772            mov y+1,a
0844 F536       773            mov y+2,a
0846 F537       774            mov y+3,a
0848            775   
0848 753050     776            mov x+0, #0x50
084B            777            
084B 855934     778            mov y+0, oven_temp+0
084E 855A35     779            mov y+1, oven_temp+1
0851            780   
0851 D0D0       781            pop psw
0853 D0E0       782            pop acc
0855 22         783            ret
0856            784   
0856            785   
0856            786   
0856            787   ;--------------------------------- FSM --------------------------------
0856            788   FSM1:
0856 E546       789       mov a, FSM1_state                            ; initializes which state to start from
0858            790   
0858            791   FSM1_state0:                                             ; start or not and edit settings
0858 B40039     792       cjne a, #0, FSM1_state1              ; if state is not 0, then move to the next
085B 020A0D     793       ljmp FSM_edit
085E 755800     794       mov pwm, #0                                          ; pulse width modulation set to 0
0861 754100     795            mov secs_ctr, #0
0864            796   
0864            797   FSM1_state0_done:
0864 7401       798            mov a, #0x01
0866 12019E     798            lcall ?WriteCommand
0869 C002       799            push AR2
086B 7A02       799            mov R2, #2
086D 120154     799            lcall ?Wait_Milli_Seconds
0870 D002       799            pop AR2
0872 754601     800            mov FSM1_state, #1                      ; change the state to the next
0875 754100     801            mov secs_ctr, #0
0878 754200     802            mov mins_ctr, #0
087B 754501     803            mov buzzer, #1
087E            804            
087E 020797     805       ljmp forever
0881            806   
0881            807   check_abort: 
0881 12080C     808            lcall load_abort_temp           ;if temp<50 after a min, abort.
0884 120322     809            lcall x_gt_y
0887 200001     810            jb mf, abort_process
088A 22         811            ret
088B            812   
088B            813   abort_process:
088B 755800     814            mov pwm, #0
088E 754600     815            mov FSM1_state, #0
0891 020797     816            ljmp forever
0894            817   
0894            818   FSM1_state1:                                             ; ramp to soak
0894 B4015E     819       cjne a, #1, FSM1_state2
0897 C0E0       820            push acc
0899 7401       820            mov a, #1
089B 14         820            dec a
089C 1201E3     820            lcall ?Set_Cursor_1 ; Select column and row
089F D0E0       820            pop acc
08A1 C083       821            push dph
08A3 C082       821            push dpl
08A5 C0E0       821            push acc
08A7 9000D3     821            mov dptr, #title1
08AA 1201D6     821            lcall ?Send_Constant_String
08AD D0E0       821            pop acc
08AF D082       821            pop dpl
08B1 D083       821            pop dph
08B3 C0E0       822            push acc
08B5 740D       822            mov a, #13
08B7 14         822            dec a
08B8 1201E3     822            lcall ?Set_Cursor_1 ; Select column and row
08BB D0E0       822            pop acc
08BD C000       823            push ar0
08BF A849       823            mov r0, stemp+1
08C1 1201E8     823            lcall ?Display_BCD
08C4 D000       823            pop ar0
08C6 C000       824            push ar0
08C8 A848       824            mov r0, stemp+0
08CA 1201E8     824            lcall ?Display_BCD
08CD D000       824            pop ar0
08CF 755864     825       mov pwm, #100                                        ; set power to full
08D2 7400       826            mov a, #0x00
08D4 B542AA     827            cjne a, mins_ctr, check_abort
08D7 1207BC     828            lcall load_soak_temp                    ;soak temp in x , oven in y
08DA 120364     829            lcall x_gteq_y
08DD 20000F     830            jb mf, FSM1_state1_done
08E0            831   
08E0 754602     832       mov FSM1_state, #2
08E3 7401       833            mov a, #0x01
08E5 12019E     833            lcall ?WriteCommand                             ; clear thje tiomer area
08E8 C209       834            clr soak_temp_flag
08EA D207       835       setb soak_timer_flag                 ; start the timer for soak
08EC 754300     836            mov state_secs_ctr, #0                          ;set the timer for states
08EF            837   ;-------------------------------abort subroutines---------------------
08EF            838   
08EF            839   
08EF            840   FSM1_state1_done:
08EF 754502     841            mov buzzer, #2
08F2 020797     842       ljmp forever
08F5            843   
08F5            844   FSM1_state2: ;soak
08F5 B40246     845       cjne a, #2, FSM1_state3
08F8 C0E0       846            push acc
08FA 7401       846            mov a, #1
08FC 14         846            dec a
08FD 1201E3     846            lcall ?Set_Cursor_1 ; Select column and row
0900 D0E0       846            pop acc
0902 C083       847            push dph
0904 C082       847            push dpl
0906 C0E0       847            push acc
0908 9000E7     847            mov dptr, #title2
090B 1201D6     847            lcall ?Send_Constant_String
090E D0E0       847            pop acc
0910 D082       847            pop dpl
0912 D083       847            pop dph
0914 C0E0       848            push acc
0916 740D       848            mov a, #13
0918 14         848            dec a
0919 1201E3     848            lcall ?Set_Cursor_1 ; Select column and row
091C D0E0       848            pop acc
091E C000       849            push ar0
0920 A843       849            mov r0, state_secs_ctr
0922 1201E8     849            lcall ?Display_BCD
0925 D000       849            pop ar0
0927 755814     850       mov pwm, #20
092A E543       851       mov a, state_secs_ctr
092C C3         852            clr c 
092D 954A       853            subb a, stime
092F 400A       854            jc FSM1_state2_done
0931            855   
0931 754603     856       mov FSM1_state, #3
0934 C207       857            clr soak_timer_flag
0936 7401       858            mov a, #0x01
0938 12019E     858            lcall ?WriteCommand                     ; clear thje tiomer area
093B            859   
093B            860   FSM1_state2_done:
093B            861   
093B 020797     862       ljmp forever
093E            863   
093E            864   FSM1_state3:                                             ;ramp to reflow
093E B40350     865       cjne a, #3, FSM1_state4
0941 C0E0       866            push acc
0943 7401       866            mov a, #1
0945 14         866            dec a
0946 1201E3     866            lcall ?Set_Cursor_1 ; Select column and row
0949 D0E0       866            pop acc
094B C083       867            push dph
094D C082       867            push dpl
094F C0E0       867            push acc
0951 9000FB     867            mov dptr, #title3
0954 1201D6     867            lcall ?Send_Constant_String
0957 D0E0       867            pop acc
0959 D082       867            pop dpl
095B D083       867            pop dph
095D C0E0       868            push acc
095F 740D       868            mov a, #13
0961 14         868            dec a
0962 1201E3     868            lcall ?Set_Cursor_1 ; Select column and row
0965 D0E0       868            pop acc
0967 C000       869            push ar0
0969 A84D       869            mov r0, rtemp+1
096B 1201E8     869            lcall ?Display_BCD
096E D000       869            pop ar0
0970 C000       870            push ar0
0972 A84C       870            mov r0, rtemp+0
0974 1201E8     870            lcall ?Display_BCD
0977 D000       870            pop ar0
0979 755864     871       mov pwm, #100                                        ;ramp to temp
097C 1207E4     872            lcall load_reflow_temp                  ;soak temp in x , oven in y
097F 120364     873            lcall x_gteq_y
0982 200006     874            jb mf, FSM1_state3_done
0985            875   
0985 754604     876       mov FSM1_state, #4
0988 754300     877            mov state_secs_ctr, #0                  ;resetting the state_sec_ctr
098B            878   
098B            879   FSM1_state3_done:
098B 754504     880            mov buzzer, #4
098E 020797     881       ljmp forever
0991            882   
0991            883   FSM1_state4:                                             ;reflow
0991 B40442     884       cjne a, #4, FSM1_state5
0994 C0E0       885            push acc
0996 7401       885            mov a, #1
0998 14         885            dec a
0999 1201E3     885            lcall ?Set_Cursor_1 ; Select column and row
099C D0E0       885            pop acc
099E C083       886            push dph
09A0 C082       886            push dpl
09A2 C0E0       886            push acc
09A4 90010F     886            mov dptr, #title4
09A7 1201D6     886            lcall ?Send_Constant_String
09AA D0E0       886            pop acc
09AC D082       886            pop dpl
09AE D083       886            pop dph
09B0 C0E0       887            push acc
09B2 740D       887            mov a, #13
09B4 14         887            dec a
09B5 1201E3     887            lcall ?Set_Cursor_1 ; Select column and row
09B8 D0E0       887            pop acc
09BA C000       888            push ar0
09BC A843       888            mov r0, state_secs_ctr
09BE 1201E8     888            lcall ?Display_BCD
09C1 D000       888            pop ar0
09C3 755814     889       mov pwm, #20                                         ;keep temp constant
09C6            890       
09C6 E543       891            mov a, state_secs_ctr
09C8 C3         892            clr c 
09C9 954E       893            subb a, rtime
09CB 4003       894            jc FSM1_state4_done
09CD            895   
09CD 754605     896       mov FSM1_state, #5
09D0            897   
09D0            898   
09D0            899   FSM1_state4_done:
09D0 754505     900            mov buzzer, #5
09D3 020797     901       ljmp forever
09D6            902   
09D6            903   FSM1_state5:                                             ;cooling
09D6 B40531     904       cjne a, #5, FSM1_state0_buffer
09D9 C0E0       905            push acc
09DB 7401       905            mov a, #1
09DD 14         905            dec a
09DE 1201E3     905            lcall ?Set_Cursor_1 ; Select column and row
09E1 D0E0       905            pop acc
09E3 C083       906            push dph
09E5 C082       906            push dpl
09E7 C0E0       906            push acc
09E9 900123     906            mov dptr, #title5
09EC 1201D6     906            lcall ?Send_Constant_String
09EF D0E0       906            pop acc
09F1 D082       906            pop dpl
09F3 D083       906            pop dph
09F5 755800     907       mov pwm, #0
09F8 120831     908            lcall load_cooling_temp                         ;50 in x, oven temp in y
09FB 120364     909            lcall x_gteq_y
09FE 300003     910            jnb mf, FSM1_state5_done
0A01            911   
0A01 754600     912       mov FSM1_state, #0
0A04            913   
0A04            914   
0A04            915   FSM1_state5_done:
0A04 754506     916            mov buzzer, #6
0A07 020797     917       ljmp forever
0A0A            918   
0A0A            919   FSM1_state0_buffer: ;buffer to long jump to state0
0A0A            920   
0A0A 020858     921       ljmp FSM1_state0
0A0D            922   
0A0D            923   ;-----------------------------------------------------------------
0A0D            924   
0A0D            925   ;---------------------FSM_edit--------------------
0A0D            926   FSM_edit:
0A0D E547       927            mov a, edit_state 
0A0F            928   
0A0F            929   FSM_soaktemp:
0A0F B40009     930            cjne a, #0, FSM_soaktime
0A12 020AA8     931            ljmp soaktemp
0A15            932            
0A15            933   
0A15            934   FSM_soaktemp_done:
0A15 754701     935            mov edit_state, #1
0A18 020A0D     936            ljmp FSM_edit
0A1B            937   
0A1B            938   FSM_soaktime:
0A1B B40109     939            cjne a, #1, FSM_reflowtemp
0A1E 120B1D     940            call soaktime
0A21            941   
0A21            942            
0A21            943   
0A21            944   FSM_soaktime_done:
0A21 754702     945            mov edit_state, #2
0A24 020A0D     946            ljmp FSM_edit
0A27            947   
0A27            948   FSM_reflowtemp:
0A27 B40209     949            cjne a, #2, FSM_reflowtime
0A2A 020B88     950            ljmp reflowtemp
0A2D            951   
0A2D            952            
0A2D            953   
0A2D            954   FSM_reflowtemp_done:
0A2D 754703     955            mov edit_state, #3
0A30 020A0D     956            ljmp FSM_edit
0A33            957   
0A33            958   FSM_reflowtime:
0A33 B40309     959            cjne a, #3, FSM_start
0A36 020BEF     960            ljmp reflowtime
0A39            961   
0A39            962            
0A39            963   
0A39            964   FSM_reflowtime_done:
0A39 754704     965            mov edit_state, #4
0A3C 020A0D     966            ljmp FSM_edit
0A3F            967   
0A3F            968   FSM_start:                                               ;can only start once all parameters are selected
0A3F B404CD     969            cjne a, #4, FSM_soaktemp
0A42 1206E1     970            lcall LCD_PB
0A45 C002       971            push AR2
0A47 7A4B       971            mov R2, #75
0A49 120154     971            lcall ?Wait_Milli_Seconds
0A4C D002       971            pop AR2
0A4E C0E0       972            push acc
0A50 7401       972            mov a, #1
0A52 14         972            dec a
0A53 1201E3     972            lcall ?Set_Cursor_1 ; Select column and row
0A56 D0E0       972            pop acc            ;messages for starting or editing
0A58 C083       973            push dph
0A5A C082       973            push dpl
0A5C C0E0       973            push acc
0A5E 900073     973            mov dptr, #startmsg
0A61 1201D6     973            lcall ?Send_Constant_String
0A64 D0E0       973            pop acc
0A66 D082       973            pop dpl
0A68 D083       973            pop dph
0A6A C0E0       974            push acc
0A6C 7401       974            mov a, #1
0A6E 14         974            dec a
0A6F 1201E1     974            lcall ?Set_Cursor_2 ; Select column and row
0A72 D0E0       974            pop acc            ;messages for starting or editing
0A74 C083       975            push dph
0A76 C082       975            push dpl
0A78 C0E0       975            push acc
0A7A 900085     975            mov dptr, #editmsg
0A7D 1201D6     975            lcall ?Send_Constant_String
0A80 D0E0       975            pop acc
0A82 D082       975            pop dpl
0A84 D083       975            pop dph
0A86 A206       976            mov c, start_stop                       ;start the process
0A88 5007       977            jnc FSM1_state0_done_buffer
0A8A A204       978            mov c, edit                                     ;keep on editing
0A8C 5006       979            jnc FSM_start_done
0A8E 020A3F     980            ljmp FSM_start
0A91            981   
0A91            982   
0A91            983   FSM1_state0_done_buffer:
0A91 020864     984            ljmp FSM1_state0_done
0A94            985   
0A94            986   FSM_start_done:
0A94 754700     987            mov edit_state, #0          ;clear lcd
0A97 7401       988            mov a, #0x01
0A99 12019E     988            lcall ?WriteCommand
0A9C C002       989            push AR2
0A9E 7A02       989            mov R2, #2
0AA0 120154     989            lcall ?Wait_Milli_Seconds
0AA3 D002       989            pop AR2
0AA5 020A0D     990            ljmp FSM_edit
0AA8            991   
0AA8            992   ;--------------edit fsm state functions----------------
0AA8            993   
0AA8            994   ; Assumes A register contains the value to be displayed before calling
0AA8            995   ; This routine converts the binary value in A to ASCII and displays it on the LCD
0AA8            996          
0AA8            997   soaktemp:
0AA8 1206E1     998            lcall LCD_PB                    ;evaluate the buttons
0AAB C002       999            push AR2
0AAD 7A4B       999            mov R2, #75
0AAF 120154     999            lcall ?Wait_Milli_Seconds
0AB2 D002       999            pop AR2         ;need to wait so dont need lightning button presses
0AB4 120AF6    1000            lcall stemp_change
0AB7           1001   
0AB7           1002   Display_soaktemp:
0AB7 C0E0      1003            push acc
0AB9 7401      1003            mov a, #1
0ABB 14        1003            dec a
0ABC 1201E3    1003            lcall ?Set_Cursor_1 ; Select column and row
0ABF D0E0      1003            pop acc                                         ;displaying the values.
0AC1 C083      1004            push dph
0AC3 C082      1004            push dpl
0AC5 C0E0      1004            push acc
0AC7 90002E    1004            mov dptr, #param1
0ACA 1201D6    1004            lcall ?Send_Constant_String
0ACD D0E0      1004            pop acc
0ACF D082      1004            pop dpl
0AD1 D083      1004            pop dph
0AD3 C0E0      1005            push acc
0AD5 7401      1005            mov a, #1
0AD7 14        1005            dec a
0AD8 1201E1    1005            lcall ?Set_Cursor_2 ; Select column and row
0ADB D0E0      1005            pop acc
0ADD C000      1006            push ar0
0ADF A849      1006            mov r0, stemp+1
0AE1 1201E8    1006            lcall ?Display_BCD
0AE4 D000      1006            pop ar0
0AE6 C000      1007            push ar0
0AE8 A848      1007            mov r0, stemp+0
0AEA 1201E8    1007            lcall ?Display_BCD
0AED D000      1007            pop ar0
0AEF           1008            
0AEF A204      1009            mov c, edit                             ;since is zero when pushed, if carry is on then replay
0AF1 40B5      1010            jc soaktemp
0AF3 020A15    1011            ljmp FSM_soaktemp_done
0AF6           1012   
0AF6           1013   stemp_change:
0AF6           1014       
0AF6 A202      1015            mov c, incr                             ;if increment
0AF8 5005      1016            jnc add_stemp
0AFA A203      1017            mov c, decr                             ;then check if decrement
0AFC 5010      1018            jnc sub_stemp
0AFE 22        1019            ret
0AFF           1020   
0AFF           1021   add_stemp:
0AFF C3        1022       clr c 
0B00 E548      1023            mov a, stemp+0
0B02 3430      1024       addc a, #0x30
0B04 40B1      1025       jc Display_soaktemp
0B06 E548      1026       mov a, stemp+0              ;need to re add since changed value
0B08 2401      1027            add a, #0x01
0B0A D4        1028            da a
0B0B F548      1029            mov stemp+0, a
0B0D 22        1030            ret
0B0E           1031   
0B0E           1032   sub_stemp:
0B0E C3        1033            clr c
0B0F E548      1034       mov a, stemp+0
0B11 9431      1035       subb a, #0x31
0B13 40A2      1036       jc Display_soaktemp
0B15 E548      1037       mov a, stemp+0
0B17 2499      1038            add a, #0x99
0B19 D4        1039            da a
0B1A F548      1040            mov stemp+0, a
0B1C 22        1041            ret
0B1D           1042   
0B1D           1043   soaktime:
0B1D 1206E1    1044            lcall LCD_PB                    ;evaluate the buttons
0B20 C002      1045            push AR2
0B22 7A4B      1045            mov R2, #75
0B24 120154    1045            lcall ?Wait_Milli_Seconds
0B27 D002      1045            pop AR2
0B29 120B6B    1046            lcall stime_change
0B2C           1047   
0B2C           1048   Display_soaktime:
0B2C C0E0      1049            push acc
0B2E 7401      1049            mov a, #1
0B30 14        1049            dec a
0B31 1201E3    1049            lcall ?Set_Cursor_1 ; Select column and row
0B34 D0E0      1049            pop acc                                         ;displaying the values.
0B36 C083      1050            push dph
0B38 C082      1050            push dpl
0B3A C0E0      1050            push acc
0B3C 90003F    1050            mov dptr, #param2
0B3F 1201D6    1050            lcall ?Send_Constant_String
0B42 D0E0      1050            pop acc
0B44 D082      1050            pop dpl
0B46 D083      1050            pop dph
0B48 C0E0      1051            push acc
0B4A 7401      1051            mov a, #1
0B4C 14        1051            dec a
0B4D 1201E1    1051            lcall ?Set_Cursor_2 ; Select column and row
0B50 D0E0      1051            pop acc
0B52 C000      1052            push ar0
0B54 7800      1052            mov r0, #0
0B56 1201E8    1052            lcall ?Display_BCD
0B59 D000      1052            pop ar0
0B5B C000      1053            push ar0
0B5D A84A      1053            mov r0, stime
0B5F 1201E8    1053            lcall ?Display_BCD
0B62 D000      1053            pop ar0
0B64           1054   
0B64 A204      1055            mov c, edit                             ;since is zero when pushed, if carry is on then replay 
0B66 40B5      1056            jc soaktime
0B68 020A21    1057            ljmp FSM_soaktime_done
0B6B           1058   
0B6B           1059   stime_change:
0B6B A202      1060            mov c, incr                             ;if increment
0B6D 5005      1061            jnc add_stime
0B6F A203      1062            mov c, decr                             ;then check if decrement
0B71 500B      1063            jnc sub_stime
0B73 22        1064            ret
0B74           1065   
0B74           1066   add_stime:
0B74 E54A      1067       mov a, stime+0              ;need to re add since changed value
0B76 2401      1068            add a, #0x01
0B78 D4        1069            da a
0B79 F54A      1070            mov stime+0, a
0B7B 0550      1071            inc stime_bcd
0B7D 22        1072            ret
0B7E           1073   
0B7E           1074   sub_stime:
0B7E E54A      1075       mov a, stime+0
0B80 2499      1076            add a, #0x99
0B82 D4        1077            da a
0B83 F54A      1078            mov stime+0, a
0B85 1550      1079            dec stime_bcd
0B87 22        1080            ret
0B88           1081   
0B88           1082   
0B88           1083   reflowtemp:
0B88 1206E1    1084            lcall LCD_PB                    ;evaluate the buttons
0B8B C002      1085            push AR2
0B8D 7A4B      1085            mov R2, #75
0B8F 120154    1085            lcall ?Wait_Milli_Seconds
0B92 D002      1085            pop AR2
0B94 120BD6    1086            lcall rtemp_change
0B97           1087            
0B97           1088   Display_reflowtemp:
0B97 C0E0      1089            push acc
0B99 7401      1089            mov a, #1
0B9B 14        1089            dec a
0B9C 1201E3    1089            lcall ?Set_Cursor_1 ; Select column and row
0B9F D0E0      1089            pop acc                                         ;displaying the values.
0BA1 C083      1090            push dph
0BA3 C082      1090            push dpl
0BA5 C0E0      1090            push acc
0BA7 900050    1090            mov dptr, #param3
0BAA 1201D6    1090            lcall ?Send_Constant_String
0BAD D0E0      1090            pop acc
0BAF D082      1090            pop dpl
0BB1 D083      1090            pop dph
0BB3 C0E0      1091            push acc
0BB5 7401      1091            mov a, #1
0BB7 14        1091            dec a
0BB8 1201E1    1091            lcall ?Set_Cursor_2 ; Select column and row
0BBB D0E0      1091            pop acc
0BBD C000      1092            push ar0
0BBF A84D      1092            mov r0, rtemp+1
0BC1 1201E8    1092            lcall ?Display_BCD
0BC4 D000      1092            pop ar0
0BC6 C000      1093            push ar0
0BC8 A84C      1093            mov r0, rtemp+0
0BCA 1201E8    1093            lcall ?Display_BCD
0BCD D000      1093            pop ar0
0BCF           1094   
0BCF A204      1095            mov c, edit                             ;since is zero when pushed, if carry is on then replay 
0BD1 40B5      1096            jc reflowtemp
0BD3 020A2D    1097            ljmp FSM_reflowtemp_done
0BD6           1098   
0BD6           1099   rtemp_change:
0BD6 A202      1100            mov c, incr                             ;if increment
0BD8 5005      1101            jnc add_rtemp
0BDA A203      1102            mov c, decr                             ;then check if decrement
0BDC 5009      1103            jnc sub_rtemp
0BDE 22        1104            ret
0BDF           1105   
0BDF           1106   add_rtemp:
0BDF E54C      1107       mov a, rtemp+0              ;need to re add since changed value
0BE1 2401      1108            add a, #0x01
0BE3 D4        1109            da a
0BE4 F54C      1110            mov rtemp+0, a
0BE6 22        1111            ret
0BE7           1112   
0BE7           1113   sub_rtemp:
0BE7 E54C      1114       mov a, rtemp+0
0BE9 2499      1115            add a, #0x99
0BEB D4        1116            da a
0BEC F54C      1117            mov rtemp+0, a
0BEE 22        1118            ret
0BEF           1119   
0BEF           1120   reflowtime:
0BEF 1206E1    1121            lcall LCD_PB                    ;evaluate the buttons
0BF2 C002      1122            push AR2
0BF4 7A4B      1122            mov R2, #75
0BF6 120154    1122            lcall ?Wait_Milli_Seconds
0BF9 D002      1122            pop AR2
0BFB 120C3D    1123            lcall rtime_change
0BFE           1124            
0BFE           1125   Display_reflowtime:
0BFE C0E0      1126            push acc
0C00 7401      1126            mov a, #1
0C02 14        1126            dec a
0C03 1201E3    1126            lcall ?Set_Cursor_1 ; Select column and row
0C06 D0E0      1126            pop acc                                         ;displaying the values.
0C08 C083      1127            push dph
0C0A C082      1127            push dpl
0C0C C0E0      1127            push acc
0C0E 900061    1127            mov dptr, #param4
0C11 1201D6    1127            lcall ?Send_Constant_String
0C14 D0E0      1127            pop acc
0C16 D082      1127            pop dpl
0C18 D083      1127            pop dph
0C1A C0E0      1128            push acc
0C1C 7401      1128            mov a, #1
0C1E 14        1128            dec a
0C1F 1201E1    1128            lcall ?Set_Cursor_2 ; Select column and row
0C22 D0E0      1128            pop acc
0C24 C000      1129            push ar0
0C26 7800      1129            mov r0, #0x00
0C28 1201E8    1129            lcall ?Display_BCD
0C2B D000      1129            pop ar0
0C2D C000      1130            push ar0
0C2F A84E      1130            mov r0, rtime
0C31 1201E8    1130            lcall ?Display_BCD
0C34 D000      1130            pop ar0
0C36           1131   
0C36 A204      1132            mov c, edit                             ;since is zero when pushed, if carry is on then replay 
0C38 40B5      1133            jc reflowtime
0C3A 020A39    1134            ljmp FSM_reflowtime_done
0C3D           1135   
0C3D           1136   rtime_change:
0C3D A202      1137            mov c, incr                             ;if increment
0C3F 5005      1138            jnc add_rtime
0C41 A203      1139            mov c, decr                             ;then check if decrement
0C43 500B      1140            jnc sub_rtime
0C45 22        1141            ret
0C46           1142   
0C46           1143   add_rtime:
0C46 E54E      1144       mov a, rtime+0              ;need to re add since changed value
0C48 2401      1145            add a, #0x01
0C4A D4        1146            da a
0C4B F54E      1147            mov rtime+0, a
0C4D 0552      1148            inc rtime_bcd
0C4F 22        1149            ret
0C50           1150   
0C50           1151   sub_rtime:
0C50 E54E      1152       mov a, rtime+0
0C52 2499      1153            add a, #0x99
0C54 D4        1154            da a
0C55 F54E      1155            mov rtime+0, a
0C57 0552      1156            inc rtime_bcd
0C59 22        1157            ret
0C5A           1158   ;------------------------------------------------------
0C5A           1159   
0C5A           1160   EN
